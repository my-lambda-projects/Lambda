<!DOCTYPE html>
<html>

  <head>
    <link href="./prism.css" rel="stylesheet" />
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico" />
    <link rel="preload" as="font" type="font/woff" crossorigin="anonymous"
      href="https://lambdaschool-content-cdn.s3.amazonaws.com/fonts/SuisseIntl-Light-WebM.woff" />
    <link rel="preload" as="font" type="font/woff" crossorigin="anonymous"
      href="https://lambdaschool-content-cdn.s3.amazonaws.com/fonts/SuisseIntl-Regular-WebM.woff" />
    <link rel="preload" as="font" type="font/woff" crossorigin="anonymous"
      href="https://lambdaschool-content-cdn.s3.amazonaws.com/fonts/SuisseIntl-Medium-WebM.woff" />
    <link rel="preload" as="font" type="font/woff" crossorigin="anonymous"
      href="https://lambdaschool-content-cdn.s3.amazonaws.com/fonts/TiemposHeadlineWeb-Regular.woff" />
    <link rel="preload" as="font" type="font/woff" crossorigin="anonymous"
      href="https://lambdaschool-content-cdn.s3.amazonaws.com/fonts/TiemposHeadlineWeb-RegularItalic.woff" />
    <meta name="viewport" content="width=device-width" />
    <meta charSet="utf-8" />
    <title>Codex</title>
    <meta name="robots" content="noindex, nofollow" />
    <meta name="next-head-count" content="4" />
    <link rel="preload" href="/_next/static/css/1ec660952bfce6d06822.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/1ec660952bfce6d06822.css" data-n-g="" /><noscript
      data-n-css=""></noscript>
    <link rel="preload" href="/_next/static/chunks/main-bcea29cef485d2ff4f28.js" as="script" />
    <link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script" />
    <link rel="preload" href="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" as="script" />
    <link rel="preload" href="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.1d7278d5916139ff8fd5.js"
      as="script" />
    <link rel="preload" href="/_next/static/chunks/pages/_app-bc37be3f9ebfb49934f6.js" as="script" />
    <link rel="preload" href="/_next/static/chunks/62fd6c6d.3169d2aaf47600f9c274.js" as="script" />
    <link rel="preload" href="/_next/static/chunks/5a6ca47b17dc4bcb9b0bc3131ee7e9f4fd30e305.b64ed04365f9737cb9ea.js"
      as="script" />
    <link rel="preload"
      href="/_next/static/chunks/pages/tracks/%5BtrackSlug%5D/units/%5BunitSlug%5D/sprints/%5BsprintSlug%5D-2093e8ce28f6da0e7dee.js"
      as="script" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="./w1-style.css">
  </head>

  <body>
    <div class="container">
      <script src="/prism.js"></script>
      <div id="__next">
        <div class="flex px-4 items-center border-b border-gray-300 bg-white w-screen h-14"><a href="/"><img
              src="https://lambdaschool-content-cdn.s3.amazonaws.com/images/lambda-codex-logo.svg"
              alt="Lambda Codex Logo" style="height:30px" /></a></div>
        <div class="px-3 bg-gray-100 w-screen min-h-screen-minus-top-bar">
          <div
            class="hidden lg:block-important lg:left-nav-container-lg xl:left-nav-container-2xl 2xl:left-nav-container-6xl">
            <div class="ml-auto w-48 whitespace-pre-wrap"><span
                class="lambda-link relative font-sans text-lg leading-tight font-normal block font-bold text-gray-800 mb-2">MODULES</span>
              <ul class="list-none">
                <li class="mb-2 leading-none"><a target="_self" href="#module-dom-i"
                    class="cursor-pointer font-sans text-blue-600 underline"><span
                      class="lambda-link relative font-sans text-sm leading-snug font-normal">DOM I</span></a></li>
                <li class="mb-2 leading-none"><a target="_self" href="#module-dom-ii"
                    class="cursor-pointer font-sans text-blue-600 underline"><span
                      class="lambda-link relative font-sans text-sm leading-snug font-normal">DOM II</span></a></li>
                <li class="mb-2 leading-none"><a target="_self" href="#module-components-i"
                    class="cursor-pointer font-sans text-blue-600 underline"><span
                      class="lambda-link relative font-sans text-sm leading-snug font-normal">Components I</span></a>
                </li>
                <li class="mb-2 leading-none"><a target="_self" href="#module-components-ii"
                    class="cursor-pointer font-sans text-blue-600 underline"><span
                      class="lambda-link relative font-sans text-sm leading-snug font-normal">Components II</span></a>
                </li>
              </ul>
            </div>
          </div>
          <main
            class="flex flex-col mx-auto w-full md:max-w-md lg:w-lg lg:max-w-lg xl:w-2xl xl:max-w-2xl 2xl:w-6xl 2xl:max-w-6xl">
            <div class="mt-2">
              <nav aria-label="Breadcrumbs" class="lambda-breadcrumbs">
                <ol class="flex flex-wrap list-none p-0 truncate">
                  <li><a class="lambda-breadcrumbs-item text-blue-600 no-underline" href="/"><span
                        class="lambda-link relative font-sans text-xs leading-snug font-normal">Tracks</span></a><span
                      aria-hidden="true" class="text-gray-900 text-opacity-25 p-2">/</span></li>
                  <li><a class="lambda-breadcrumbs-item text-blue-600 no-underline"
                      href="/tracks/web-development/"><span
                        class="lambda-link relative font-sans text-xs leading-snug font-normal">Web
                        Development</span></a><span aria-hidden="true"
                      class="text-gray-900 text-opacity-25 p-2">/</span>
                  </li>
                  <li><a class="lambda-breadcrumbs-item text-blue-600 no-underline"
                      href="/tracks/web-development/units/webapplications-i/"><span
                        class="lambda-link relative font-sans text-xs leading-snug font-normal">WebApplications-I</span></a><span
                      aria-hidden="true" class="text-gray-900 text-opacity-25 p-2">/</span></li>
                  <li><span aria-disabled="true" role="link" aria-current="page"
                      class="lambda-breadcrumbs-item lambda-breadcrumbs-item-current text-slate-600"><span
                        class="lambda-link relative font-sans text-xs leading-snug font-normal">Applied
                        JavaScript</span></span></li>
                </ol>
              </nav>
            </div>
            <div class="mt-8"><span
                class="lambda-link relative font-sans text-sm leading-snug font-normal text-gray-700">SPRINT 1</span>
              <h1 class="lambda-link relative font-serif text-4xl leading-tight font-normal page-title">Applied
                JavaScript
              </h1>
            </div>
            <div class="lg:hidden mt-8"><span
                class="lambda-link relative font-sans text-lg leading-tight font-normal block font-bold text-gray-800 mb-2">MODULES</span>
              <ul class="list-none">
                <li class="mb-2 leading-none"><a target="_self" href="#module-dom-i"
                    class="cursor-pointer font-sans text-blue-600 underline"><span
                      class="lambda-link relative font-sans text-sm leading-snug font-normal">DOM I</span></a></li>
                <li class="mb-2 leading-none"><a target="_self" href="#module-dom-ii"
                    class="cursor-pointer font-sans text-blue-600 underline"><span
                      class="lambda-link relative font-sans text-sm leading-snug font-normal">DOM II</span></a></li>
                <li class="mb-2 leading-none"><a target="_self" href="#module-components-i"
                    class="cursor-pointer font-sans text-blue-600 underline"><span
                      class="lambda-link relative font-sans text-sm leading-snug font-normal">Components I</span></a>
                </li>
                <li class="mb-2 leading-none"><a target="_self" href="#module-components-ii"
                    class="cursor-pointer font-sans text-blue-600 underline"><span
                      class="lambda-link relative font-sans text-sm leading-snug font-normal">Components II</span></a>
                </li>
              </ul>
            </div>
            <div class="mt-8">
              <div class="generated-html">
                <section>
                  <div>
                    <h2 id="overview">Overview</h2>
                    <p>This week is all about exposing you to applying your Javascript knowledge to the Document Object
                      Model and creating rich Javascript user interfaces.</p>
                    <h2 id="dom-i">DOM I</h2>
                    <p>Now that we can build a basic static web page with HTML and CSS, we need to add functionality to
                      the page. The first step in building vibrant dynamic web pages and applications is learning about
                      the DOM. What it is, how it affects our page, and how to access and manipulate it. DOM
                      manipulation
                      is at the core of every framework and before we start using frameworks we need to understand the
                      DOM.</p>
                    <h2 id="dom-ii">DOM II</h2>
                    <p>Events are the way we users interact with the page. Any time there is some interaction by way of
                      a
                      mouse, keyboard, etc., the DOM creates and propagates an event object. This event object carries
                      information about the event so that it may be handled at any point up the tree from the point of
                      origin.</p>
                    <h2 id="components-i">Components I</h2>
                    <p>As we build larger and more feature rich web pages, we may notice a trend in our code; elements
                      that are essentially using the same functionality and styling with minor differences in the data
                      they present. In an effort to keep our code readable, reusable, and most of all DRY, we can build
                      on
                      these repeating patterns and create components. Components are reusable pieces of code that can be
                      used to build elements sharing functionality and styling. Components are the heart of any dynamic
                      web application and JavaScript framework.</p>
                    <h2 id="components-ii">Components II</h2>
                    <p>Now that we have some understanding of what a component is, we can learn to utilize asynchronous
                      JavaScript and Promises to make HTTP requests and get data from a server.</p>
                  </div>
                </section>
                <section>
                  <h1 id="module-dom-i">DOM I</h1>
                  <div>
                    <ul>
                      <li>
                        <p><a href="https://youtu.be/XydfZvsoOJw">Web FT36 w/ Gabriel Cabrejas</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/z0HgLLkH824">Web PT21 w/ Emily Seibert</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/sbsp7jszknQ">Web PT19 w/ Emily Seibert</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/vhwIgo7yy58">Web PT18 w/ Keiran Kozlowski</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/Ihf8rnmzdmQ">Web PT16 w/ Dan Frehner</a></p>
                      </li>
                    </ul>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/cr0762ej29"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <p>When a web page is loaded into a browser, the browser first looks for the HTML file. The browser
                      uses the HTML file as a blueprint, or instructions on how to build the page (this coupled with the
                      CSS file later). The browser parses these instructions and builds a model for how the page should
                      look and act using Javascript. This model is a Javascript Object containing every element in order
                      on the page. This Object is referred to as the DOM, or Document Object Model.</p>
                    <p>The DOM is built as a data structure known as a &apos;Tree&apos;, because parent elements have
                      nested children elements (or leaves). As with physical trees, we can follow branches of the tree
                      to
                      get to the exact leaf (or leaves) that we want to access. Each branch of our DOM tree can be
                      it&apos;s own tree. It is important to remember this as we move through this lesson.</p>
                    <p><img src="https://tk-assets.lambdaschool.com/b75e53cc-0f0d-40c3-8f3f-31cc49eab207_dom-tree.jpg"
                        alt="DOM tree"></p>
                    <p>When the DOM is built and the webpage is loaded, developers get access to it in the form of the
                      global Javascript object <code>document</code>. <code>document</code> contains the entire
                      hierarchy
                      of the page, each element (or DOM node), and it also contains dozens of built in methods and
                      properties. We can use these methods and properties to manipulate what we see on the screen.</p>
                    <ul>
                      <li>Note: There are so many methods and properties on document (and its subsequent elements and
                        collections) that it would take a lot longer to properly cover them all. We will only be
                        covering
                        the few most commonly used. From this point forward you will be expected to reference the
                        official
                        documentation to learn more about the different methods and properties available, when your need
                        arises for something other than what we have taught. This is a very good habit to get into as we
                        progress deeper in to the course.</li>
                    </ul>
                    <h2 id="follow-along">Follow Along</h2>
                    <h3 id="dom-investigation">DOM Investigation</h3>
                    <p>Lets investigate the DOM together by visiting a live website and updating the DOM. Follow these
                      steps in order:</p>
                    <p><strong>Prerequisite: This tutorial assumes you are using Google Chrome. You can get similar
                        results in any other browser but these steps were tailored for a chrome experience.</strong></p>
                    <ol>
                      <li>Navigate to <a href="https://lambdaschool.com/">lambdaschool.com</a>.</li>
                      <li>Right click on the main heading and you should see a dropdown with an option to <code>inspect
                          element.</code> Click that option and chrome developer tools should activate.</li>
                      <li>The developer tools should be showing the selection you made when you right clicked. Double
                        click the content of the heading. You should now be able to edit the text of the header.</li>
                      <li>Update the text with anything you&apos;d like. For this example, I will update the text to say
                        &quot;Hello there!&quot; <em>You won&apos;t see any changes until you deselect the content in
                          the
                          chrome developer tools.</em></li>
                      <li>Now try updating the content and HTML of other elements on the page.</li>
                    </ol>
                    <p>Notice that if you refresh the page, the changes you made are gone! <strong>That is because the
                        elements you were editing existed in the DOM and were not permanent!</strong></p>
                    <p>You now have experience editing the DOM without writing code. Go check out the challenge below to
                      see the DOM inside the console!</p>
                    <h2 id="challenge">Challenge</h2>
                    <p>Open the console in your web browser and enter <code>console.log(document);</code>.</p>
                    <p>This should make the document appear on the screen, play around with it for a minute. Notice how
                      the document contains all of the HTML elements (otherwise now known as DOM nodes) on the page.
                      Hover
                      over these nodes and notice how the element on the page is highlighted.</p>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/q0orhsemfk"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <h3 id="dom-selectors">DOM Selectors</h3>
                    <p>Now that we know how to access the DOM using Javascript, we need a way to select individual
                      elements (or groups of them). Doing so will give us access to all live elements and allow us to
                      manipulate them.</p>
                    <p>To manipulate elements on the DOM, we need to select them. There are many ways of doing this; for
                      example, we can select the body and the head just by asking for them (document.body,
                      document.head).
                      But, when we want to go deeper, that&apos;s where things get complicated. Thankfully,
                      <code>document</code> has several built-in methods for accessing the exact element(s) we want.</p>
                    <p><strong>It is important to note that all of these methods are case sensitive. If you are unsure
                        of
                        the case while using them, please refer to the official documentation.</strong></p>
                    <h4 id="getelement-methods"><code>getElement</code> Methods</h4>
                    <p>These are the original methods for selecting elements from the DOM. They each take a single
                      string
                      as the only argument, containing either the id or class you are looking for.</p>
                    <pre><code class="javascript language-javascript">document.getElementsByTagName(&apos;p&apos;);</code></pre>
                    <p>This method will take a single string as an argument containing the element name of the elements
                      you want to select. It will return an array-like object called an <code>HTMLCollection</code>
                      containing all the elements that contain the element name supplied. We will discuss what
                      a<code>HTMLCollection</code> is after we talk about the rest of our selector methods.</p>
                    <pre><code class="javascript language-javascript">document.getElementById(&apos;idName&apos;);</code></pre>
                    <p>This method will take a single string as an argument containing the id of an element, search
                      through the DOM, and return the matching element.</p>
                    <pre><code class="javascript language-javascript">document.getElementsByClassName(&apos;className&apos;);</code></pre>
                    <p>This method will take a single string as an argument containing the class of the elements you
                      want
                      to select. It will return an array-like object called an <code>HTMLCollection</code> containing
                      all
                      of the elements that hold the given class.</p>
                    <h4 id="queryselector-methods"><code>querySelector</code> Methods</h4>
                    <p>These are the newest element selection methods added to the DOM. These methods allow us to select
                      element(s) based on CSS style selectors (remember <code>.</code> is class and <code>#</code> is
                      id).
                      Each method takes a string containing the selectors and returns the element(s). Note - we can
                      select
                      by element, id, class, or others with both methods.</p>
                    <pre><code class="javascript language-javascript">document.querySelector(&apos;.custom-style&apos;);</code></pre>
                    <p>This method will search for and return the <strong>first element</strong> that matches the value
                      passed into the method. Remember from above that the biggest change from the older DOM selection
                      methods is that we now need to pass the proper CSS selector into the argument.</p>
                    <p>If we passed <code>(&apos;custom-style&apos;)</code> and not
                      <code>(&apos;.custom-style&apos;)</code> we would error out.</p>
                    <pre><code class="javascript language-javascript">document.querySelectorAll(&apos;queryString&apos;);</code></pre>
                    <p>This method will search for and return <em>ALL</em> elements matching the query string. This
                      method
                      returns these elements in an array-like object called a <code>NodeList</code></p>
                    <h4 id="the-difference-between-htmlcollection-nodelist-and-array">The Difference between
                      <code>HTMLCollection</code>, <code>NodeList</code>, and <code>Array</code></h4>
                    <p>When we use <code>getElementsByClassName()</code> or <code>querySelectorAll()</code> we get back
                      either an <code>HTMLCollection</code> or a <code>NodeList</code> respectively. We refer these to
                      as
                      &apos;array-like objects.&apos; We have seen an array-like object before (the
                      <code>arguments</code>
                      object in a function). They both have numerical zero-based indices and the length property, but
                      that
                      is all they share with an Array. <code>NodeList</code> does take it one step further, and has
                      access
                      to <code>.forEach</code>. There are no <code>.reduce</code> or <code>.map</code> or any other
                      array
                      method.</p>
                    <p><strong>Pro tip:</strong> The <code>Array</code> class contains a method we can use to create an
                      array from an array-like object, called <code>.from()</code>. To use this, we would give
                      <code>.from</code> the array-like object as its only argument.</p>
                    <pre><code class="javascript language-javascript">Array.from(arrayLikeObject)</code></pre>
                    <h2 id="follow-along">Follow Along</h2>
                    <h3 id="selector-tutorial">Selector Tutorial</h3>
                    <p>Let&apos;s get some practice using different selector methods. You can use <a
                        href="https://codepen.io/lambdaschool/pen/eLaXXb?editors=1010">this code</a> or write your own.
                    </p>
                    <p>Study this HTML first:</p>
                    <pre><code class="html language-html"> &lt;header&gt;
    &lt;h1 class=&quot;main-header&quot;&gt;Selectors!&lt;/h1&gt;
    &lt;nav class=&quot;main-nav&quot;&gt;
      &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;Home&lt;/a&gt;
      &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;About&lt;/a&gt;
      &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;Blog&lt;/a&gt;
      &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;Contact&lt;/a&gt;
    &lt;/nav&gt;
  &lt;/header&gt;</code></pre>
                    <h4 id="queryselector"><code>querySelector()</code></h4>
                    <p>What if we wanted to select all the first <code>a</code> tags within our navigation? There are
                      several ways to accomplish this task, but let&apos;s use <code>querySelector()</code> to get
                      started.</p>
                    <p>When working with the DOM, we may want to re-use the reference several times in our code.
                      Let&apos;s declare a <code>const</code> to hold our DOM reference:</p>
                    <pre><code class="javascript language-javascript">const mySelection = document.querySelector(&apos;a&apos;);</code></pre>
                    <p>Notice we had to use <code>document</code> in front of <code>querySelector()</code> that is
                      because
                      querySelector is a method of the document object.</p>
                    <p>Next, let&apos;s log the result of our selection.</p>
                    <pre><code class="javascript language-javascript">const mySelection = document.querySelector(&apos;a&apos;);
console.log(mySelection);</code></pre>
                    <p>We should see this log in the console:</p>
                    <pre><code class="javascript language-javascript">&quot;&lt;a href=&apos;#&apos; class=&apos;nav-item&apos;&gt;Home&lt;/a&gt;&quot;</code></pre>
                    <p>We now have access to that element node in the DOM! What if we wanted to select multiple elements
                      at once? We have just the method for that: <code>querySelectorAll()</code>.</p>
                    <h4 id="queryselectorall"><code>querySelectorAll()</code></h4>
                    <p>If you recall from the introduction to selectors, <code>querySelectorAll()</code> will allow us
                      to
                      return an array-like object called a <code>NodeList</code>. Let&apos;s set up a new const for our
                      new selection:</p>
                    <pre><code class="javascript language-javascript">const multipleSelections = document.querySelectorAll(&apos;a&apos;);</code></pre>
                    <p>Notice that all we changed on the right side of the operator was adding an &quot;All&quot; to
                      &quot;querySelector.&quot; The returned value is very different though, check your console&apos;s
                      log to see what happened. If you are using chrome developer tools, you will see something like
                      this
                      in your console:</p>
                    <pre><code class="javascript language-javascript">NodeList(4)
  0: a.nav-item
  1: a.nav-item
  2: a.nav-item
  3: a.nav-item
  length: 4
  __proto__: NodeList</code></pre>
                    <p>Wow, that is totally different than our result from <code>querySelector()</code> in the first
                      example! We now have a <code>NodeList</code> and all of the nodes matching the <code>a</code>
                      elements.</p>
                    <p>What can we do with a <code>NodeList</code>? You can <a
                        href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">dig deeper into the
                        documentation</a>, but for our tutorial, let&apos;s see how it is &quot;array-like.&quot;</p>
                    <p>Study this code:</p>
                    <pre><code class="javascript language-javascript">const multipleSelections = document.querySelectorAll(&apos;a&apos;);
console.log(multipleSelections[2]);</code></pre>
                    <p>Notice the <code>multipleSelections[2]</code>. That looks very similar to how we can use indices
                      in
                      arrays. The log result from the code above should read as follows:</p>
                    <pre><code class="javascript language-javascript">&quot;&lt;a href=&apos;#&apos; class=&apos;nav-item&apos;&gt;Blog&lt;/a&gt;&quot;</code></pre>
                    <p>Being able to access elements in this way is extremely powerful and will allow you to be creative
                      if an HTML solution is not possible. Imagine you didn&apos;t have a class or ID to hook into, you
                      could use the <code>NodeList</code> index to get the job done!</p>
                    <h4 id="dont-forget-the-selector">Don&apos;t Forget The Selector</h4>
                    <p>When using <code>querySelectorAll()</code> don&apos;t forget it requires you to use the proper
                      CSS
                      selector. Using the same HTML example:</p>
                    <pre><code class="html language-html">&lt;header&gt;
  &lt;h1 class=&quot;main-header&quot;&gt;Selectors!&lt;/h1&gt;
  &lt;nav class=&quot;main-nav&quot;&gt;
    &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;Home&lt;/a&gt;
    &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;About&lt;/a&gt;
    &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;Blog&lt;/a&gt;
    &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;Contact&lt;/a&gt;
  &lt;/nav&gt;
&lt;/header&gt;</code></pre>
                    <p>Use querySelectorAll() to select all the <code>nav-item</code> classes:</p>
                    <pre><code class="javascript language-javascript">const multipleClasses = document.querySelectorAll(&apos;.nav-item&apos;);</code></pre>
                    <p>Note that we had to type out the <code>.</code> in <code>.nav-item</code>. This trips up new
                      developers to JavaScript all the time. If you were to log out the results of this session, you
                      would
                      see it&apos;s just a <code>NodeList</code> like before, but now it&apos;s using classes instead of
                      the <code>a</code> element. Push yourself further by using the challenge below!</p>
                    <h2 id="challenge">Challenge</h2>
                    <p>Finish the DOM selector requests based on given HTML, LESS, and JS <a
                        href="https://codepen.io/lambdaschool/pen/mGYarw?editors=1010">- follow this link for the
                        challenge.</a></p>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/vruue7h0zh"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <p>Now that we have access to element(s), we can start to manipulate them and change their
                      characteristics from the original html.</p>
                    <p>After we have captured our element (eg. <code>const el =
                        document.querySelector(&apos;#idName&apos;);</code> we can use that instance of the element we
                      selected to access and assign values to properties natively contained on it. Once again, there are
                      dozens of properties and methods given to us on each element. Here are a few of the most commonly
                      used properties:</p>
                    <h4 id="textcontent">.textContent</h4>
                    <ul>
                      <li>Gets and sets the text of an element. Essentially whatever text is between the open and
                        closing
                        tags of an HTML element.</li>
                      <li>Can use the assignment operator ( = ) to reset the text of an element</li>
                      <li>Setting this property on a node removes all of its children and replaces them with the new
                        single text node.</li>
                      <li><code>&lt;div&gt;Something Here&lt;/div&gt;</code></li>
                      <li><code>element.textContent = &apos;Something New</code>;</li>
                    </ul>
                    <h4 id="setattribute-or-attr">.setAttribute() (or .{attr})</h4>
                    <ul>
                      <li>This method (or property) is used as a way to set or reassign an attribute on the element.
                      </li>
                      <li>&apos;.setAttribute()&apos; is a method that takes two arguments, the attribute to set, and
                        the
                        value to set to that attribute.</li>
                      <li>eg: <code>element.setAttribute(&apos;src&apos;,
                          &apos;http://www.imagsource.com/image.jpg&apos;)</code></li>
                      <li>Can also use the pattern: <code>element.&apos;attrName&apos; = &apos;value&apos;</code>.</li>
                      <li>eg: <code>element.src = &apos;http://www.imagsource.com/image.jpg&apos;</code></li>
                    </ul>
                    <h4 id="style">.style</h4>
                    <ul>
                      <li>Every element contains a style object. This property accesses that style object. The style
                        object contains every available style as a key and a value as the value. It is important to
                        note,
                        that these are NOT the CSS styles, these are inline HTML styles.</li>
                      <li>These styles are associated with the HTML inline style set on the element<ul>
                          <li>eg: <code>&lt;div style=&quot;color: red;&quot;&gt;DIV STUFF&lt;/div&gt;</code></li>
                        </ul>
                      </li>
                      <li>You can access and change a property on the style object by using the assignment operator
                        <code>=</code>.</li>
                      <li>eg: <code>element.style.color = &apos;blue&apos;;</code></li>
                      <li>Changing a property on the style object will effectively give this element an inline style.
                      </li>
                      <li>Inline styles have the highest specificity, overriding any other selector except
                        <code>!important</code>.</li>
                      <li>VERY IMPORTANT to note that this does NOT access or change anything in the CSS file.</li>
                    </ul>
                    <h4 id="classname-id">.className, .id</h4>
                    <ul>
                      <li><code>.className</code> accesses or assigns a string containing all of the classes on the
                        element.</li>
                      <li><code>.id</code> accesses or assigns a string containing the id of the element.</li>
                    </ul>
                    <h4 id="classlist">.classList</h4>
                    <ul>
                      <li><code>classList</code> will return an array-like object of all the classes on the element.
                        There
                        are many useful methods available on <code>classList</code>.<ul>
                          <li><code>classList</code> is a <code>DOMTokenList</code>.</li>
                          <li>A <code>DOMTokenList</code> is an array-like object with a numerical zero-based index, a
                            length property, also the <code>.contains()</code> and <code>.forEach()</code> methods.</li>
                          <li>Most notably the methods <code>.add()</code> <code>.remove()</code> and
                            <code>.toggle()</code> exist. All three take a single string representing the class.<ul>
                              <li><code>.add(&apos;className&apos;)</code> and
                                <code>.remove(&apos;className&apos;)</code>
                                do as their names indicate.</li>
                              <li><code>.toggle(&apos;className&apos;)</code> will add the class if it does not exist
                                and
                                remove it if if does.</li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                    </ul>
                    <h4 id="appendchild-and-prepend">.appendChild() and .prepend()</h4>
                    <ul>
                      <li>These methods add child elements to parent elements.</li>
                      <li><code>.appendChild(child)</code> will take an element and add it to it&apos;s children. It
                        will
                        add it to the &apos;end&apos; physically so if the children are displayed in order it will be
                        the
                        last.<ul>
                          <li>eg: <code>parentElement.appendChild(childElement)</code></li>
                        </ul>
                      </li>
                      <li><code>.prepend(child)</code> adds a child to the beginning, displaying it first.<ul>
                          <li>eq: <code>parentElement.prepend(childElement)</code></li>
                        </ul>
                      </li>
                    </ul>
                    <h4 id="children-and-parentnode">.children and .parentNode</h4>
                    <ul>
                      <li>These properties are used for accessing relatives of the element.</li>
                      <li><code>.children</code> returns an <code>HTMLCollection</code> of all the children of that
                        element.</li>
                      <li><code>.parentNode</code> returns the parent element of that element.</li>
                    </ul>
                    <h2 id="follow-along">Follow Along</h2>
                    <h3 id="dom-manipulation-tutorial">DOM Manipulation Tutorial</h3>
                    <p>Let&apos;s get some practice manipulating the DOM. You can use <a
                        href="https://codepen.io/lambdaschool/pen/jvjjGB?editors=1011">this code as a base for your
                        JavaScript</a> or write your own HTML and CSS along the way.</p>
                    <h4 id="updating-text">Updating Text</h4>
                    <p>When we want to update the text using the DOM, the go-to property is called
                      <code>textContent</code>. We can both read and write text inside of elements using
                      <code>textContent</code>.</p>
                    <p>Given this HTML, lets make some updates to the text:</p>
                    <pre><code class="html language-html">&lt;h2 class=&quot;second-heading&quot;&gt;I am the DOM&lt;/h2&gt;</code></pre>
                    <p>First, lets set up a reference to our element on the DOM:</p>
                    <pre><code class="javascript language-javascript">  const secondHeading = document.querySelector(&apos;.second-heading&apos;);</code></pre>
                    <p>We are now prepared to update the content of our heading. Let&apos;s update the content to say
                      &quot;DOM updated!&quot;</p>
                    <pre><code class="javascript language-javascript">  secondHeading.textContent = &quot;DOM updated!&quot;;</code></pre>
                    <p>Notice that we are first getting the text node of the element and then setting a new value!</p>
                    <p><strong>Security Note</strong> You may read about <code>innerHTML</code> in your DOM learning.
                      Avoid using <code>innerHTML</code> as it could potentially be used as an attack vector for cross
                      site attacks.</p>
                    <h2 id="updating-attributes">Updating Attributes</h2>
                    <p>Updating HTML attributes is vital to DOM manipulation. Let&apos;s update the style for the
                      <code>h1</code> in the code below.</p>
                    <pre><code class="html language-html">&lt;header&gt;
  &lt;h1 class=&quot;main-header&quot;&gt;Dom Manipulation&lt;/h1&gt;
  &lt;nav class=&quot;main-nav&quot;&gt;
    &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;Home&lt;/a&gt;
    &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;About&lt;/a&gt;
    &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;Blog&lt;/a&gt;
    &lt;a href=&quot;#&quot; class=&quot;nav-item&quot;&gt;Contact&lt;/a&gt;
  &lt;/nav&gt;
&lt;/header&gt;</code></pre>
                    <p>Updating the DOM usually happens in two steps:</p>
                    <h3 id="step-1-select-the-element">Step 1: Select the element</h3>
                    <pre><code class="javascript language-javascript">const mainHeader = document.querySelector(&apos;.main-header&apos;);</code></pre>
                    <h3 id="step-2-use-the-desired-attribute-property-to-update-the-element">Step 2: Use the desired
                      attribute property to update the element</h3>
                    <pre><code class="javascript language-javascript">mainHeader.style.color = &apos;red&apos;;</code></pre>
                    <p>You can even chain the two steps together like this:</p>
                    <pre><code class="javascript language-javascript">const mainHeader = document.querySelector(&apos;.main-header&apos;).style.color = &apos;red&apos;;</code></pre>
                    <p>This two-step process can be repeated for other attributes as well! What if we had an empty
                      <code>src</code> attribute on an image tag? Let&apos;s try it out provided we have this HTML:</p>
                    <pre><code class="html language-html">&lt;img class=&quot;custom-img&quot; src=&quot;&quot; alt=&quot;Kitty image&quot; /&gt;</code></pre>
                    <p>Select the image element&apos;s class and update the <code>src</code> attribute with this link:
                    </p>
                    <p>
                      <code>https://images.pexels.com/photos/20787/pexels-photo.jpg?auto=compress&amp;cs=tinysrgb&amp;h=350</code>
                    </p>
                    <pre><code class="javascript language-javascript">const customImg = document.querySelector(&apos;.custom-img&apos;);

customImg.src = &apos;https://images.pexels.com/photos/20787/pexels-photo.jpg?auto=compress&amp;cs=tinysrgb&amp;h=350&apos;;</code></pre>
                    <h3 id="javascript-css-syntax">JavaScript CSS Syntax</h3>
                    <p>When using JavaScript to update CSS style properties, we need to be careful to remember that
                      JavaScript does not accept dashes as a valid naming value! Whenever a CSS property contains a
                      dash,
                      we must use camel casing in JavaScript.</p>
                    <p>Example:</p>
                    <pre><code class="css language-css">.some-class {
  background-color: gray;
}</code></pre>
                    <p>The JavaScript version would look like this:</p>
                    <pre><code class="javascript language-javascript">  const someClass = document.querySelector(&apos;.some-class&apos;);

  someClass.style.backgroundColor = &quot;gray&quot;;</code></pre>
                    <p><strong>Pro Tip:</strong> Don&apos;t forget the string when you assign a value to a CSS property.
                    </p>
                    <h2 id="challenge">Challenge</h2>
                    <h3 id="dom-manipulation-challenge">DOM Manipulation Challenge</h3>
                    <p><a href="https://codepen.io/lambdaschool/pen/jvjjGB?editors=1011">Take the example code from your
                        tutorial</a> and try updating the DOM in various ways.</p>
                    <p>Here are some ideas:</p>
                    <ul>
                      <li>Change the color of the paragraphs</li>
                      <li>Change the text contents of any element of your choosing</li>
                      <li>Change the <code>href</code> of an anchor tag</li>
                      <li>Update the <code>alt</code> tag of an image</li>
                      <li>Update layout styles, try out flex properties with JavaScript syntax</li>
                    </ul>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/q66qu8ziiw"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <p>An important feature of the DOM is the ability to create brand new elements dynamically. Using
                      the
                      <code>document.createElement()</code> method, we will be able to create a brand new element, style
                      it, and add it anywhere on the DOM we would like.</p>
                    <h2 id="follow-along">Follow Along</h2>
                    <h3 id="createelement">.createElement</h3>
                    <ul>
                      <li><code>.createElement</code> creates a brand new element based on a given string.</li>
                      <li>New element exists in memory, but not on the DOM yet.</li>
                      <li>Can use any DOM property or method to style and manipulate the element.</li>
                      <li>eg: <code>document.createElement(&apos;h1&apos;)</code> will create an <code>h1</code>
                        element.
                      </li>
                    </ul>
                    <h3 id="appendchild-and-prepend">.appendChild() and .prepend()</h3>
                    <ul>
                      <li>Add child elements to parent elements.</li>
                      <li><code>.appendChild(child)</code> add an element to it&apos;s children. Adds to the
                        &apos;end&apos;, so that if displayed in order, the added child will be last.<ul>
                          <li>eg: <code>parentElement.appendChild(childElement)</code></li>
                        </ul>
                      </li>
                      <li><code>.prepend(child)</code> adds a child to the beginning, displaying it first.<ul>
                          <li>eq: <code>parentElement.prepend(childElement)</code></li>
                        </ul>
                      </li>
                    </ul>
                    <h2 id="challenge">Challenge</h2>
                    <p>Practice the concepts covered.</p>
                  </div>
                </section>
                <section>
                  <h1 id="module-dom-ii">DOM II</h1>
                  <div>
                    <ul>
                      <li>
                        <p><a href="https://youtu.be/iXgoHYWJRBI">Web FT36 w/ Gabriel Cabrejas</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/6oDYvbUUHXo">Web PT22 w/ Keiran Kozlowski</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/FhozK2bwTV8">Web PT21 w/ Emily Seibert</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/Io8k-9Ozy8Y">Web PT18 w/ Keiran Kozolwski</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/Yar3Llxhifs">Web PT16 w/ Dan Frehner</a></p>
                      </li>
                    </ul>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/s9te7mjbtc"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <p>In preprocessing, there are three main concepts we need to understand:</p>
                    <ol>
                      <li>The language or syntax that we use to write our code (LESS)</li>
                      <li>The compiler that converts the language (Node)</li>
                      <li>The CSS output from the compiler (Normal CSS)</li>
                    </ol>
                    <p>This module focuses on the compiler. For us to use our language (LESS), we need to have a
                      compiler
                      that understands that specific language input. </p>
                    <p>A compiler is a program that converts language into code. In our case, LESS is the language, and
                      CSS is the outputted code. We utilize compilers to provide more features than standard CSS can
                      offer. </p>
                    <h2 id="follow-along">Follow Along</h2>
                    <p>Installing our working environment can be daunting at first. We will be covering a lot of ground.
                      Get through each step before going back and trying to learn everything you did. </p>
                    <p>If you are on a mac, follow the mac instructions below. If you are on a PC, scroll down after the
                      mac instructions to the PC instructions. If you are on Linux, chances are Node is already
                      installed
                      in your system. Run <code>node -v</code> in a shell to make sure, and then you can look at step 3
                      in
                      the mac instructions.</p>
                    <h3 id="step-by-step-install-instructions-for-mac">Step By Step Install Instructions for Mac</h3>
                    <p><strong><em>Step 1: <a href="https://brew.sh/">Install Homebrew and Node</a></em></strong></p>
                    <ul>
                      <li>Follow the instructions on how to install Homebrew using your terminal</li>
                      <li>Pay attention to your terminal as the installer will ask for a password</li>
                      <li>Once Homebrew is installed, run <code>brew install node</code> in your terminal</li>
                      <li>Pay attention to your terminal, as there might be small issues to troubleshoot</li>
                      <li>Restart your terminal after installation</li>
                      <li>Run <code>node -v</code> in your terminal to make sure node was installed correctly</li>
                    </ul>
                    <p><strong><em>Step 2: Install Less</em></strong><br>
                      <em>NOTE:</em> You will see our commands have <code>-g</code> in them. Please write the commands
                      exactly as you see them. Globally installing packages is ideal for our situation.</p>
                    <ul>
                      <li>Open terminal and run <code>npm install -g less</code></li>
                      <li>If it&apos;s not working, restart your terminal and try again</li>
                    </ul>
                    <p><strong><em>Step 3: Install less-watch-compiler</em></strong></p>
                    <ul>
                      <li>Open the terminal and run <code>npm install -g less-watch-compiler</code></li>
                    </ul>
                    <p><strong><em>Step 4: Use less-watch-compiler On Your Project</em></strong></p>
                    <ul>
                      <li>Fork and clone <a
                          href="https://github.com/LambdaSchool/Preprocessing-Part-I">Preprocessing-Part-I</a></li>
                      <li><code>cd</code> into your project on your local machine</li>
                      <li>Once you are in the root of your project run <code>less-watch-compiler less css
                          index.less</code> </li>
                      <li>Your project should be up and running, change some styles around in your .less file, and save
                        the file to make sure you see a change in your CSS.</li>
                      <li>Great work, you&apos;re all set up!</li>
                    </ul>
                    <h3 id="step-by-step-install-instructions-for-pc">Step By Step Install Instructions for PC</h3>
                    <p><strong><em>Step 1: <a href="https://nodejs.org/en/">Install Node.js</a></em></strong></p>
                    <p><strong><em>Step 2: <a href="https://git-scm.com/download/win">Install Git Bash (Git
                            SCM)</a></em></strong></p>
                    <ul>
                      <li>After the installer finishes, open git bash and run <code>node -v</code> to make sure node is
                        installed correctly</li>
                      <li>If you don&apos;t see some node version numbers display in your git bash window, restart git
                        bash and try again</li>
                    </ul>
                    <p><strong><em>Step 3: Install Less</em></strong></p>
                    <p><em>NOTE:</em> You will see our commands have <code>-g</code> in them. Please write the commands
                      exactly as you see them. Globally installing packages is ideal for our situation.</p>
                    <ul>
                      <li>Open git bash and run <code>npm install -g less</code></li>
                      <li>If it&apos;s not working, restart your git bash and try again</li>
                    </ul>
                    <p><strong><em>Step 4: Install less-watch-compiler</em></strong></p>
                    <ul>
                      <li>Open git bash and run <code>npm install -g less-watch-compiler</code></li>
                    </ul>
                    <p><strong><em>Step 5: Use less-watch-compiler On Your Project</em></strong></p>
                    <ul>
                      <li>Fork and clone <a
                          href="https://github.com/LambdaSchool/Preprocessing-Part-I">Preprocessing-Part-I</a></li>
                      <li><code>cd</code> into your project on your local machine</li>
                      <li>Once you are in the root of your project run <code>less-watch-compiler less css
                          index.less</code> </li>
                      <li>Your project should be up and running, change some styles around in your .less file, and save
                        the file to make sure you see a change in your CSS.</li>
                      <li>Great work, you&apos;re all set up!</li>
                    </ul>
                    <h2 id="challenge">Challenge</h2>
                    <ol>
                      <li>Follow the instructions provided to you in the tutorial above.</li>
                      <li>Once in your project, change the background color of your body tag to <code>red</code>.</li>
                      <li>Once the background turns red, your compiler is working correctly.</li>
                    </ol>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/dq31jsdein"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>


                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/psrcnzxk0l"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <p>We use Javascript to make our pages dynamic and usable. Now that we can access and manipulate
                      elements on our page, you might be wondering to yourself, &quot;Why don&apos;t we just change the
                      elements in the HTML file directly? Why do we have to go through all of this just to change some
                      styling on an element?&quot; Those are valid questions, and the way we have been using Javascript
                      so
                      far, it would make sense to change our HTML instead.</p>
                    <p>But, Javascript&apos;s real power lies in its ability to make webpages interactive. In addition
                      to
                      manipulating elements, Javascript also allows us to add features and make modifications to our
                      site
                      by directly reacting to user interactions. Think about a button click, drag and drop, zoom, or any
                      number of user interactions. We create functionality for those interactions using JavaScript. Now
                      that we know how to manipulate and modify DOM nodes, we can learn about events.</p>
                    <p>Every user interaction with a site is an event: a click, moving the mouse, scrolling the page,
                      pressing a key on the keyboard, these are all events on the page, and the browser can detect all
                      of
                      them. There are tons of different events the browser tracks. When an event happens on a page, it
                      is
                      known as a trigger.</p>
                    <p>Now that we know what an event is and we know the browser is always tracking them, we need to be
                      able to listen for specific events on specific elements. Did a user click that button? Did a users
                      mouse hover over an element? Was there text entered into the input field? There are dozens of
                      events
                      an element can listen for. When one of those events happens on that element, we can do something
                      about it. The tracking process and subsequent action taken is called an event listener. We put an
                      event listener on an element and give it a callback. When that event is triggered on the element,
                      the callback is run.</p>

                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/shtn02rjnt"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <h3 id="addeventlistener">.addEventListener</h3>
                    <p>Once we have an element selected, we can use the &apos;.addEventListener&apos; method on that
                      element. <code>.addEventListener</code> takes two arguments, first the event to listen for and,
                      second, the callback to fire when that event is triggered. For a complete list of events see the
                      resources below. In use, this looks something like
                      <code>element.addEventListener(&apos;click&apos;,
                        callback);</code>.</p>
                    <h3 id="events">Events</h3>
                    <p>We learned before that there are different types of events we can listen for. The most common are
                      mouse events highlighted by the &apos;click&apos; event, but there are dozens of more events we
                      can
                      listen for. We can add event listeners for as many events as there are for each element, meaning
                      we
                      can listen for a <code>mouseclick</code>, <code>keypress</code>, <code>hover</code>, and more all
                      on
                      the same element. Although to do so we need to call <code>.addEventListener</code> and pass in a
                      callback for each one.</p>
                    <p>Take 5 minutes and study this MDN page. Choose an event that is NOT a mouse event, and read about
                      it and how it works.</p>
                    <p><a href="https://developer.mozilla.org/en-US/docs/Web/Events">MDN Event Listeners</a></p>
                    <h3 id="the-callback-and-the-event-object">The callback and the <code>Event Object</code></h3>
                    <p>The callback (also known as an event handler) will take a single argument; this is known as the
                      <code>Event Object</code>. This is a Javascript Object and contains all we need to know about the
                      event and the element it happened on. </p>
                    <ul>
                      <li>eg: <code>element.addEventListener(&apos;click&apos;, (event) =&gt; {//Handle event});</code>
                      </li>
                      <li>One of the most important properties of the event object is <code>.target</code>, this
                        property
                        will give us all of the info about the DOM node where the event happened. It has many of the
                        same
                        properties as a regular DOM node, <code>.children</code>, <code>.parent</code>,
                        <code>.style</code>, <code>innerText</code>, etc. We can use these properties to manipulate the
                        element itself, or it&apos;s relatives. </li>
                      <li>We can use this to manipulate the target in any way we want, for example to change the
                        background color we would write the following: <code>element.addEventListener(&apos;click&apos;,
                          (event) =&gt; { event.target.style.backgroundColor = &apos;blue&apos;; });</code></li>
                      <li>Depending on the type of event listened for, we can have access to other information about the
                        event as well, such as the key pressed (in the form of a code) and other things. Spend 5 minutes
                        reading about the event object here: <a
                          href="https://developer.mozilla.org/en-US/docs/Web/API/Event#Properties">MDN Event Object:
                          Properties</a></li>
                    </ul>

                    <h2 id="challenge">Challenge</h2>
                    <p>Follow the instructions in the Javascript section of this codepen on your own. Use the
                      <code>sampleButton</code> element at the top as a reference, and add the appropriate event
                      listeners
                      to the elements. Please Fork and save your code, and share it with your TL.</p>
                    <p><a href="https://codepen.io/lambdaschool/pen/gqmrwx?editors=0010">Codepen: DOM-II Events</a></p>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/4gxn61w9au"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <p>Think of a pyramid. Pyramids are made up of many layers, the bottom layer is the largest and as
                      it
                      goes higher, ever decreasing sized layers are added to the one before it. If you are standing on
                      the
                      uppermost layer of a pyramid, you are also standing on every layer below it. When we look at a DOM
                      tree we can see those child elements are nested inside parent elements, like a pyramid. And, like
                      a
                      pyramid, if you stand(trigger an event) on a child element, you are also triggering that same
                      event
                      on every parent element all the way up to the body. This process is called event propagation. If
                      you
                      have an event of the same type on a parent element and a child element, and you trigger that event
                      on the child element, it will also trigger on the parent. We have to be careful not to create
                      unwanted interactions because of this. In the future, you may consider this is a feature, for now,
                      this is something we would like to avoid.</p>
                    <p>In our event handler, we are passed the event object. The event object has lots of methods and
                      properties on it including one called <code>.stopPropagation()</code> if we call this method in
                      our
                      event handler, it will effectively stop our event from bubbling any further up the chain. </p>
                    <ul>
                      <li>eg: <code>const eventHandler = (event) =&gt; { event.stopPropagation() };</code></li>
                    </ul>
                    <h4 id="preventdefault">.preventDefault</h4>
                    <p>Some elements have a native default reaction to certain events. For example, form elements will
                      refresh the page on submit. <code>.preventDefault</code> is a method on the event object, and it
                      will stop an HTML element from reacting in its default way. <code>.preventDefault</code> will be
                      used less than <code>.stopPropagation</code>, but it is important to know about as well.</p>

                    <h2 id="challenge">Challenge</h2>
                    <p>Go back to the codepen you were working on. And complete steps 9 - 12.</p>
                  </div>
                </section>
                <section>
                  <h1 id="module-components-i">Components I</h1>
                  <div>
                    <ul>
                      <li>
                        <p><a href="https://youtu.be/yyAS8K_EcM8">Web FT36 w/ Gabriel Cabrejas</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/X0ZQ4QNdyyo">Web PT19 w/ Emily Seibert</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/0piuGvzoEQQ">Web PT18 w/Keiran Kozlowski</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/mAnvvOhz_oA">WEB PT16 w/ Dan Frehner</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/-jnp9FxCsYU">WEB PT15 w/ Emily Seibert</a></p>
                      </li>
                    </ul>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/zfuvchtxn3"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <h3 id="components">Components</h3>
                    <p>A component is made of several parts: HTML, CSS, or JavaScript brought together for reuse in a
                      website or application.</p>
                    <h4 id="components---html">Components - HTML:</h4>
                    <p>When building HTML with a component mentality, you need to ask the question: &quot;What am I
                      trying
                      to display from my data?&quot;</p>
                    <p>Because we are focused on user interface concepts, we don&apos;t need to access a database at
                      this
                      point. For us, static HTML is data, since it is, after all, what we&apos;re trying to display.</p>
                    <p>Review the following code:</p>
                    <pre><code class="html language-html">&lt;div class=&quot;custom-buttons&quot;&gt;
  &lt;button&gt;Button 1&lt;/button&gt;
  &lt;button&gt;Button 2&lt;/button&gt;
  &lt;button&gt;Button 3&lt;/button&gt;
  &lt;button&gt;Button 4&lt;/button&gt;
&lt;/div&gt;</code></pre>
                    <p>Notice we have repeating <code>&lt;button&gt;&lt;/button&gt;</code> tags. This is an opportunity
                      for us to think about how we could use our CSS and JavaScript to create multiple buttons
                      regardless
                      of how many buttons we have to work with. The HTML gives us a great starting point for a button
                      component, but we need to style it for reuse.</p>
                    <h3 id="components---css">Components - CSS:</h3>
                    <p>Writing CSS for components is more about rationale than syntax. Components should be modular or
                      stand-alone. With that in mind, you should try to think of your component CSS in a way that could
                      be
                      moved around at any moment and not reliant on any other styles being in place.</p>
                    <p>One way that can help you control your styles is to use a specificity chain that only matches up
                      with your component. You could use a specific class name to accomplish this:</p>
                    <pre><code class="html language-html">&lt;div class=&quot;custom-buttons&quot;&gt;
  &lt;button class=&quot;custom-btn&quot;&gt;Button 1&lt;/button&gt;
  &lt;button class=&quot;custom-btn&quot;&gt;Button 2&lt;/button&gt;
  &lt;button class=&quot;custom-btn&quot;&gt;Button 3&lt;/button&gt;
  &lt;button class=&quot;custom-btn&quot;&gt;Button 4&lt;/button&gt;
&lt;/div&gt;</code></pre>
                    <p><em>Naming conventions vary wildly in the work place. The recommendation is to adjust to the
                        standards decided on by your employer.</em></p>
                    <p>If you&apos;re using a preprocessor, a common practice is to have your preprocessed file named
                      after the component. You could then import your component name into the main file. Here is an
                      example of the import you could use and then what the file could look like:</p>
                    <pre><code class="less language-less">@import custom-btn.less</code></pre>
                    <pre><code class="less language-less">.custom-btn {
  // custom styles here
}</code></pre>
                    <p>You may be thinking, &quot;wait, that&apos;s it?&quot; Yep! Using components is as simple as
                      building styles so that they don&apos;t rely on any other element on the page and don&apos;t bleed
                      over into another component.</p>
                    <h3 id="components-javascript">Components: JavaScript:</h3>
                    <p>JavaScript is used to consume the data and output the content into the DOM. JavaScript&apos;s
                      involvement in components is the glue that ties everything together. We can use Javascript to
                      consume the HTML and return a component version of it! The how-to of JavaScript will be explained
                      in
                      greater detail throughout the rest of our objectives.</p>
                    <h2 id="follow-along">Follow Along</h2>
                    <p>Let&apos;s identify component patterns in the wild. Lets go to a social media platform and
                      discuss
                      how components are used.</p>
                    <h2 id="challenge">Challenge</h2>
                    <p>Go to your favorite social media platform and practice identifying how components are used
                      throughout the app. Screenshot a component and try recreating the HTML, CSS. You could even try to
                      create simple DOM interactions in JavaScript.</p>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/v9t4bu7ber"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <p>Sometimes it makes sense to build several elements with similar functionality. Perhaps lots of
                      components have click handlers that use the same callback, or a group of components shares the
                      same
                      style. This verbosity can be frustrating, but thankfully, it isn&apos;t necessary to repeat
                      yourself
                      in code. Utilizing a Javascript function, we can create dynamic components on the fly and add them
                      to the DOM.</p>
                    <h3 id="createelement">createElement</h3>
                    <p>We know about the <code>.createElement</code> method in our previous lessons. We learned that it
                      could build DOM elements that we can later add to the DOM.</p>
                    <p>We also learned that once we create an element, we can use any property or method on it as we use
                      on an element selected from the DOM. We can even add event listeners to the newly formed element.
                    </p>
                    <pre><code class="javascript language-javascript">let button = document.createElement(&apos;button&apos;);

button.textContent = &apos;Button 1&apos;;

button.classList.add(&apos;button&apos;);

button.addEventListener(&apos;click&apos;, (e) =&gt; {
    console.log(&apos;clicked!&apos;);
});

parent.appendChild(button);</code></pre>
                    <h3 id="functions">functions</h3>
                    <p>Now, sticking with that last example, let&apos;s imagine we want to create many buttons on our
                      page. We could very quickly repeat the code there for each button we want to create, appending
                      them
                      to the parent each time. Although from our knowledge so far, we know that repeating ourselves is
                      something we want to avoid. We can easily compartmentalize all of the code into a function.
                      Looking
                      back on that last example, can you identify the pieces that might change? Anything that may
                      change,
                      we can add in as an argument, everything else will stay the same. This function will allow us to
                      create components.</p>
                    <pre><code class="javascript language-javascript">function buttonCreator(buttonText){
    const button = document.createElement(&apos;button&apos;);

    button.textContent = buttonText;

    button.classList.add(&apos;button&apos;);

    button.addEventListener(&apos;click&apos;, (e) =&gt; {
        console.log(&apos;clicked!&apos;);
    });

    return button;
}

let firstButton = buttonCreator(&apos;Button 1&apos;);

let secondButton = buttonCreator(&apos;Button 2&apos;);

parent.appendChild(firstButton);
parent.appendChild(secondButton);</code></pre>
                    <p>And just like that, we can create as many new <code>button</code> components we want without
                      repeating ourselves!</p>

                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/2obb51cs1e"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <p>In the next lesson, we will learn how to retrieve dynamic data, but for now, we are going to
                      build
                      and use our own array. Let&apos;s imagine that this data can change and may not always look like
                      how
                      we built it. We want a way to create components based on the data present. This data can come in
                      many different forms. In this simple case, we are using an array of strings:</p>
                    <pre><code class="javascript language-javascript">const data = [
    &quot;Button One&quot;,
    &quot;Button Two&quot;,
    &quot;Button Three&quot;,
    &quot;Button Four&quot;
]</code></pre>
                    <p>Let&apos;s use the <code>buttonCreator</code> function from the last objective:</p>
                    <pre><code class="javascript language-javascript">function buttonCreator(buttonText){
    const button = document.createElement(&apos;button&apos;);

    button.textContent = buttonText;

    button.classList.add(&apos;button&apos;);

    button.addEventListener(&apos;click&apos;, (e) =&gt; {
        console.log(&apos;clicked!&apos;);
    });

    return button;
})</code></pre>
                    <h3 id="foreach">.forEach</h3>
                    <p>One of the simplest array methods is <code>.forEach</code> - it runs the array through a loop,
                      passing each item to our callback function. It doesn&apos;t return a new array or mutate the data
                      at
                      all (unless we tell it to). <code>.forEach</code> is a simple way to iterate over the array,
                      create
                      components, and add them instantly to the DOM.</p>
                    <pre><code class="javascript language-javascript">data.forEach((arrayItem) =&gt; {
  let newButton = buttonCreator(arrayItem);

  parent.appendChild(newButton);
});</code></pre>
                    <p>That was super simple! Just like that, we created a new component for each item in the array and
                      added it to the DOM. No matter how many items are in the array, it will still work. One downside
                      to
                      this method is that we add the items to the DOM instantly, what if we wanted to create the
                      components and add them at a different time?</p>
                    <h3 id="map">.map</h3>
                    <p>We know that <code>.map</code> returns a new array with the items transformed (by our callback).
                      We
                      can then do whatever we please with this array.</p>
                    <pre><code class="javascript language-javascript">let newComponents = data.map((arrayItem) =&gt; {
  let newButton = buttonCreator(arrayItem);

  // Remember, we always need to return something when we use .map
  return newButton;
});</code></pre>
                    <p>Now that we have an array of DOM elements (components), we can do whatever we&apos;d like with
                      them. We can wait to add the components to the DOM, or we can manipulate them further, the sky is
                      the limit! Let&apos;s add them to the DOM now, using .forEach</p>
                    <pre><code class="javascript language-javascript">newComponents.forEach(component =&gt; {
  parent.appendChild(component);
});</code></pre>

                  </div>
                </section>
                <section>
                  <h1 id="module-components-ii">Components II</h1>
                  <div>
                    <ul>
                      <li>
                        <p><a href="https://youtu.be/DgrJ6bcyqDI">Web FT36 w/ Gabriel Cabrejas</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/Xq-5u5TzKv4">Web PT21 w/ Emily Seibert</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/w49aH-VVN14">Web PT19 w/ Emily Seibert</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/HI0EFhyHXTM">Web PT18 w/ Keiran Kozolwski</a></p>
                      </li>
                      <li>
                        <p><a href="https://youtu.be/XAMKKuJH7PY">Web PT15 w/ Emily Seibert</a></p>
                      </li>
                    </ul>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/5dbzxf5557"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <h3 id="asynchronous-code">Asynchronous code</h3>
                    <p>In JavaScript we have the concept of &apos;asynchronous&apos; code. This simply means code that
                      does not run instantly in line. Perhaps the code needs to wait a moment, wait for something to
                      happen, or in the case we will explore today, wait until data comes back from a server. Using
                      asynchronous code can be challenging at first because we need to be able to recognize which code
                      will be asynchronous and which will run instantly. Take the following example, which will run
                      instantly and which will wait to run?</p>
                    <pre><code class="javascript language-javascript">setTimeout( () =&gt; {
    console.log(&apos;Hello!&apos;);
}, 1000);

console.log(&apos;Over here!&apos;);</code></pre>
                    <p>Even if you have never seen <code>setTimeout</code> before, you probably realized that it will
                      wait
                      a moment to run, where console.log will run instantly. If you run this code in your console you
                      should see <code>Over here!</code> print first because setTimeout will wait 1 second (1000 ms) to
                      run.</p>
                    <p>Asynchronous code is everywhere in Javascript. It is an important concept to begin to understand.
                    </p>
                    <h3 id="promises">Promises</h3>
                    <p>We have a few different ways to approach asynchronous code, in the last example we saw the use of
                      callbacks (which you already understand). Other concepts are <code>async/await</code> and
                      <code>Promises</code>. Today we will be using Promises.</p>
                    <p>Promises are a design pattern for use when handling asynchronous code in JavaScript. We use them
                      as
                      an alternative to nesting multiple callbacks. You may have heard of a problem called
                      <code>callback</code> hell. Promises are a way to avoid this problem.</p>
                    <p>Implementing promises is not something you&apos;ll need to do very often, especially in front end
                      development. However, understanding how they work under the hood will help you deal with them, for
                      example when requesting data from web servers.</p>
                    <p>Learning how to handle promises is pretty straight forward. In fact, on a <code>Promise</code>
                      object there are really only two methods that we need to use to handle promises <code>then</code>
                      and <code>catch</code>. For what we&apos;re trying to accomplish in terms of transferring data
                      between our apps and some server somewhere, we will actually be using what is called a
                      <code>Promise
                        Library</code>. I want to ensure that you understand that the built in <code>Promise</code>
                      object
                      you&apos;re about to see, is <strong>NOT</strong> a promise library, rather it is a feature built
                      into the JavaScript language as of ES6. Now, let&apos;s dig in.</p>
                    <p>Consider the following code and what it is doing here.</p>
                    <pre><code class="javascript language-javascript">let time = 0;
const timeMachine = () =&gt; {
  return setTimeout(() =&gt; {
    return time += 1000;
  }, 1000);
};

timeMachine();
console.log(time); --&gt; OUTPUTS: 0;</code></pre>
                    <p>What we have seen here is that at some point in time, the setTimeout function (1 second later)
                      will
                      actually end up manipulating the <code>time</code> variable. However, when we
                      <code>console.log</code> time we get <code>0</code>. The reason for this, is because of the way
                      the
                      <code>time</code> variable is defined. It is happening inside of a <code>setTimeout</code> block,
                      which waits 1000ms to actually do its thing. This is an important concept to grasp here. <em>Even
                        though we&apos;ve manipulated the data, we don&apos;t have access to the data that was
                        manipulated
                        quite yet</em>. In a nutshell this is asynchronous JavaScript.</p>
                    <p>Ok, so the problem, is that we&apos;re expecting <code>time</code> to be equal to
                      <code>1000</code>
                      by the time we want to work with it. One way we can solve this is by using Promises. Before we do
                      that let&apos;s figure out what a <code>promise</code> is first.</p>
                    <p>Straight from MDN:</p>
                    <blockquote>
                      <p><em>A Promise is a proxy for a value not necessarily known when the promise is created. It
                          allows
                          you to associate handlers with an asynchronous action&apos;s eventual success value or failure
                          reason. This lets asynchronous methods return values like synchronous methods: instead of
                          immediately returning the final value, the asynchronous method returns a promise to supply the
                          value at some point in the future.</em></p>
                    </blockquote>
                    <p>Simply put, a Promise is just that, a promise from the object that it will let us know when it
                      has
                      completed (or errored) what we have asked it to do. A promise can exist in one of three states:
                    </p>
                    <ul>
                      <li><code>Pending</code>: a state where the promise is neither rejected nor fulfilled. (this is
                        the
                        state it is in when we first call it)</li>
                      <li><code>Fulfilled</code>: a state where <em>all&apos;s well</em> and a resolved value can be
                        used
                        by our code.</li>
                      <li><code>Rejected</code>: a state where <em>something went wrong</em> and there is an error that
                        needs to be dealt with.</li>
                    </ul>
                    <p>If the promise succeeds, it will return the value as a parameter into a callback passed into
                      <code>.then()</code>. If the promise fails, the callback passed into the <code>.catch()</code>
                      runs,
                      taking an error as its argument.</p>
                    <h2 id="follow-along">Follow Along</h2>
                    <p>Ok that&apos;s a lot of words, now lets see some code.</p>
                    <ul>
                      <li>Reminder, we <em>are</em> building our own promise here, although you will <em>not</em> need
                        to
                        do this on your own today.</li>
                    </ul>
                    <pre><code class="javascript language-javascript">let time = 0;
const timeMachine = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve((time += 1000));
    }, 1000);
  });
};</code></pre>
                    <p>Notice here that we&apos;ve now wrapped our <code>setTimeout</code> function in a <code>new
                        Promise</code> and we&apos;re resolving the addition of the <code>time += 1000</code> and
                      passing
                      that resolved result. This allows us to do what we call <code>promise chaining</code> when we
                      invoke
                      our <code>timeMachine</code> function. Remember that every promise ships with <code>then and
                        catch</code> methods and we can use those methods to either receive a <code>resolved
                        promise</code> or a <code>rejected promise</code>. Lets find out how!</p>
                    <pre><code class="javascript language-javascript">timeMachine()
    .then(newTime =&gt; {
       console.log(newTime); --&gt; OUTPUTS: 1000
    });</code></pre>
                    <p>Ok, in the above code, the <code>thenified</code> timeMachine invocation is now receiving a
                      callback itself, (this is how all promise chains should look) with some item being received as a
                      parameter. We can chain multiple <code>thens</code> together. Inside of each <code>then</code>
                      block
                      when/if we return something new, we can be directed into a new <code>then</code> block which is
                      really neat. Or maybe we&apos;re <code>resolving</code> more than one process, and we want to see
                      the next result in the next <code>then</code> block. Lets manipulate the data in the
                      <code>.then</code> block we have now, and see what happens when we use another <code>then</code>.
                    </p>
                    <pre><code class="javascript language-javascript">timeMachine()
  .then(newTime =&gt; {
    const myTime = newTime / 1000;
    return `${myTime} seconds have passed`;
  })
  .then(newString =&gt; {
    console.log(newString); --&gt; OUTPUTS &#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&quot;1 seconds have passed&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&quot;
  });</code></pre>
                    <p>In our first <code>then</code> block we are manipulating the time that is originally being
                      resolved
                      by the <code>Promise</code> and then sequentially returning it with some text concatenated onto
                      the
                      time. Because we are returning a value from our first <code>then</code> statement, we can now
                      chain
                      on another <code>then</code>. And thus we have achieved some promise chaining. This isn&apos;t a
                      terribly useful program at this point. But we&apos;re about to see some power.</p>
                    <p>Now lets make another function that we can use to return yet another promise. This is where some
                      of
                      the <code>then chaining</code> starts to really come in handy. We&apos;re going to have to
                      refactor
                      our code, ONLY where we&apos;re calling <code>timeMachine</code>. The function we&apos;re going to
                      write is called <code>parseTime</code> and it will receive a <code>ms</code> milliseconds
                      parameter
                      that we can use to reject a promise in the future.</p>
                    <pre><code class="javascript language-javascript">const parseTime = ms =&gt; {
  return new Promise((resolve, reject) =&gt; {
    const timeString = time / 1000;
    resolve(`${timeString} seconds have passed`);
  });
};</code></pre>
                    <p>Ok! Now we&apos;ve offloaded some work from our <code>then</code> block into a function that
                      resolves a promise. We can now use it like above, but this time, when we call our
                      <code>timeMachine</code> function we&apos;ll pass this <code>parseTime</code> function as an
                      argument to our first <code>then</code> block.</p>
                    <pre><code class="javascript language-javascript">timeMachine()
  .then(parseTime)
  .then(timePassed =&gt; {
    console.log(timePassed); --&gt; OUTPUTS: &quot;1 seconds have passed&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;&quot;
  });</code></pre>
                    <p>We&apos;ve effectively achieved the same thing, but now we&apos;re chaining promises and their
                      resolves together. This is Promise chaining. Now the last thing we need to cover is a
                      <code>rejected
                        promise</code> because up until now all the things have just&#x2026; worked. That is not the
                      case
                      in the real world, so because of that, we need to learn how to handle rejections. Lets tweak our
                      <code>parseTime</code> function so that we can reject a promise instead of resolving a promise
                      that
                      is, if a certain condition matches.</p>
                    <pre><code class="javascript language-javascript">const parseTime = ms =&gt; {
  return new Promise((resolve, reject) =&gt; {
    const timeString = time / 1000;
    if (ms &gt; 999) {
      resolve(`${timeString} seconds have passed`);
    } else {
      reject(new Error(`ms is less than 1 second promise rejected!`));
    }
  });
};</code></pre>
                    <p>Here&apos;s what&apos;s going to be sweet, when this function actually runs, ms will be 1000. So
                      our condition will resolve the promise, but lets remember where we&apos;re actually using this
                      function.. it&apos;s within a <code>then</code> block on the resolve of another promise. If we
                      tweak
                      our <code>timeMachine</code> function to resolve under <code>1000 ms</code>, we&apos;ll get a
                      rejection. So lets change the <code>timeMachine</code> function in such a way that breaks our
                      promise chain so that we can deal with it.</p>
                    <pre><code class="javascript language-javascript">resolve((time += 999));</code></pre>
                    <p>Now we should hit our condition, and our promise will then be rejected. So we have a
                      <code>catch</code> block for this purpose.</p>
                    <pre><code class="javascript language-javascript">timeMachine()
  .then(parseTime)
  .then(timePassed =&gt; {
    console.log(timePassed); --&gt; OUTPUT: DOES NOT RUN
  })
  .catch(err =&gt; {
    console.log(err); --&gt; OUTPUT: &#x200B;&#x200B;&#x200B;&#x200B;&#x200B;[Error: ms is less than 1 second promise rejected!]&#x200B;&#x200B;&#x200B;&#x200B;&#x200B;
  });</code></pre>
                    <p>And that is that! We have successfully built out a promise chain that allows us to see the
                      benefit
                      of writing them in the first place. So now, when you&apos;re dealing with Promises in the future,
                      the <code>.then</code> and <code>.catch</code> won&apos;t be all that scary! That last part is the
                      part to remember. HOW we handle promises is what is important for us in the future. Not HOW we
                      implement them. We will be using Axios for that and we&apos;re going to teach you what that is
                      soon.
                    </p>
                    <h2 id="challenge">Challenge</h2>
                    <p>Using the time machine example you just built, build one more function from scratch that returns
                      a
                      <code>Promise</code> that has a setTimeout inside it. In the <code>.then()</code> console.log what
                      is resolved from inside the setTimeout.</p>
                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/1vtjx0csu6"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <h3 id="http">HTTP</h3>
                    <p>HTTP is a <em>network protocol</em>, a set of rules that govern the way web clients, like a
                      browser, communicate with web servers over the internet.</p>
                    <p>We, as developers, need to know what HTTP Methods are and how they are used to perform CRUD
                      (Create, Read, Update, Delete) operations on server resources and what HTTP status codes are and
                      what they are used for.</p>
                    <p><code>HTTP Methods</code> provide a common <em>language</em> or nomenclature that the client can
                      use to let the server know what operation it wants to perform.</p>
                    <p>When a client needs to ask a server for information it should do a GET request specifying a URL
                      that points to the desired resource.</p>
                    <p>A POST request is used to ask the server to add or <em>create</em> new resources.</p>
                    <p>The method used by the client to ask the server to make changes to specific resources is PUT.</p>
                    <p>To remove or delete data from the server the client needs to send a DELETE request.</p>
                    <p>We will see examples of how to use those methods from our React Applications.</p>
                    <p><code>HTTP Status Codes</code> are used to indicate if a <em>request</em> has been successful or
                      not and <strong>why</strong>. The server will set the status code for all responses sent to the
                      client.</p>
                    <h3 id="axios">axios</h3>
                    <p><code>axios</code> is a Javascript library. It is used to send HTTP requests to servers. It is
                      <em>not</em> necessary to do this, but it makes things much easier. Because all server requests
                      are
                      asynchronous, <code>axios</code> uses Promises. Once you get the basic pattern down,
                      <code>axios</code> is incredibly easy to use.</p>
                    <p>To read more you can check out the documentation here: <a
                        href="https://github.com/axios/axios">https://github.com/axios/axiosn</a></p>
                    <p>In this lesson we are only going to concern ourselves with the HTTP GET request, this will allow
                      us
                      to ask a server for data.</p>
                    <p>We need to start by including some code in our HTML file, this will essentially download axios
                      and
                      allow us to use it in our own javascript file.</p>
                    <p>We will put the following line in the <code>head</code> section of our HTML:</p>
                    <pre><code class="html language-html">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre>
                    <p>Now that we have access to the axios library in our Javascript file we can start to use it. For
                      now
                      we will just use it to request data from a server when we load the page, although we could request
                      that data based on user interaction, or anything really.</p>
                    <p><code>axios</code> is an object containing many methods, <code>.get</code> being one of them. It
                      takes a string as its first argument. This string is the url of the resource we are requesting:
                    </p>
                    <pre><code class="javascript language-javascript">axios.get(url)</code></pre>
                    <p>axios.get will return a Promise to us. This tells us that it is busy getting the data and will
                      return in a moment. As with all promises, we will use <code>.then</code> and <code>.catch</code>
                      to
                      deal with the data.</p>
                    <pre><code class="javascript language-javascript">axios.get(&apos;http://serverlocation.com/data&apos;)
    .then( response =&gt; {
        // deal with the response data in here
    })
    .catch( err =&gt; {
        // deal with the error in here
    })</code></pre>

                  </div>
                  <div>
                    <p>
                      <center>
                        <div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;">
                          <div class="wistia_responsive_wrapper"
                            style="height:100%;left:0;position:absolute;top:0;width:100%;"><iframe
                              allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="yes"
                              class="wistia_embed" name="wistia_embed" allowfullscreen msallowfullscreen width="100%"
                              height="100%" data-src="https://lambdaschool-1.wistia.com/medias/77g6okuf2t"></iframe>
                          </div>
                        </div>
                        <script src="https://fast.wistia.net/assets/external/E-v1.js" async></script>
                      </center>
                    </p>
                    <h2 id="overview">Overview</h2>
                    <p>Putting everything together we can now build a component function, request dynamic data from a
                      server, build components based on that data, and add those components to the DOM.</p>
                    <p>Let&apos;s see it in action:</p>
                    <p>First we will build our component creator function:</p>
                    <pre><code class="javascript language-javascript">function buttonCreator(buttonTitle){
    let newButton = document.createElement(&apos;button&apos;);
    newButton.textContent = buttonTitle;
    newButton.classList.add(&apos;button&apos;);

    return newButton;
}</code></pre>
                    <p>Next, let&apos;s grab some data. Once we receieve the data we will map over it and create
                      components out of it. Then we can add it to the DOM:</p>
                    <ul>
                      <li>One important thing to note is that the data that comes back from the server will be formatted
                        differently for every server. It is good practice to either read the documentation of the server
                        you are using, or inspect the data yourself before attempting to use it. In this example the
                        <code>response</code> object will have a key on it called <code>data</code> that key will have a
                        value of an array with a list of strings.</li>
                    </ul>
                    <pre><code class="javascript language-javascript">axios.get(&apos;http://fakeserver.com/data&apos;)
    .then( response =&gt; {
        // Remember response is an object, response.data is an array.
        response.data.forEach( item =&gt; {
            let button = buttonCreator(item);
            parent.appendChild(button);
        })
    })
    .catch( error =&gt; {
        console.log(&quot;Error:&quot;, err);
    })</code></pre>
                    <p>And there you have it! We have retrieved data, created new components based on that data, and
                      added
                      them to the DOM!</p>

                  </div>
                </section>
              </div>
            </div>
          </main>
        </div>
      </div>
    </div>
    <script id="__NEXT_DATA__" type="application/json">
      {
        "props": {
          "pageProps": {
            "track": {
              "name": "web",
              "displayName": "Web Development",
              "order": 2,
              "slug": "web-development"
            },
            "unit": {
              "name": "02-WebApplications-I",
              "displayName": "WebApplications-I",
              "slug": "webapplications-i",
              "order": 2,
              "type": "core"
            },
            "sprint": {
              "name": "Sprint 01 - Applied JavaScript",
              "displayName": "Applied JavaScript",
              "slug": "applied-javascript",
              "order": 1
            },
            "contents": [ {
              "canvasCourseId": 880,
              "title": "Home Page",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": null,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": null,
              "isHomePage": true,
              "html": "\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThis week is all about exposing you to applying your Javascript knowledge to the Document Object Model and creating rich Javascript user interfaces.\u003c/p\u003e\n\u003ch2 id=\"dom-i\"\u003eDOM I\u003c/h2\u003e\n\u003cp\u003eNow that we can build a basic static web page with HTML and CSS, we need to add functionality to the page. The first step in building vibrant dynamic web pages and applications is learning about the DOM. What it is, how it affects our page, and how to access and manipulate it. DOM manipulation is at the core of every framework and before we start using frameworks we need to understand the DOM.\u003c/p\u003e\n\u003ch2 id=\"dom-ii\"\u003eDOM II\u003c/h2\u003e\n\u003cp\u003eEvents are the way we users interact with the page. Any time there is some interaction by way of a mouse, keyboard, etc., the DOM creates and propagates an event object. This event object carries information about the event so that it may be handled at any point up the tree from the point of origin.\u003c/p\u003e\n\u003ch2 id=\"components-i\"\u003eComponents I\u003c/h2\u003e\n\u003cp\u003eAs we build larger and more feature rich web pages, we may notice a trend in our code; elements that are essentially using the same functionality and styling with minor differences in the data they present. In an effort to keep our code readable, reusable, and most of all DRY, we can build on these repeating patterns and create components. Components are reusable pieces of code that can be used to build elements sharing functionality and styling. Components are the heart of any dynamic web application and JavaScript framework.\u003c/p\u003e\n\u003ch2 id=\"components-ii\"\u003eComponents II\u003c/h2\u003e\n\u003cp\u003eNow that we have some understanding of what a component is, we can learn to utilize asynchronous JavaScript and Promises to make HTTP requests and get data from a server.\u003c/p\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Module 1 Class Recordings",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 1,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 1 - DOM I",
              "isHomePage": false,
              "html": "\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/XydfZvsoOJw\"\u003eWeb FT36 w/ Gabriel Cabrejas\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/z0HgLLkH824\"\u003eWeb PT21 w/ Emily Seibert\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/sbsp7jszknQ\"\u003eWeb PT19 w/ Emily Seibert\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/vhwIgo7yy58\"\u003eWeb PT18 w/ Keiran Kozlowski\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/Ihf8rnmzdmQ\"\u003eWeb PT16 w/ Dan Frehner\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 1 - explain what the DOM is, and how it relates to an html page",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 1,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 1 - DOM I",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/cr0762ej29\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eWhen a web page is loaded into a browser, the browser first looks for the HTML file. The browser uses the HTML file as a blueprint, or instructions on how to build the page (this coupled with the CSS file later). The browser parses these instructions and builds a model for how the page should look and act using Javascript. This model is a Javascript Object containing every element in order on the page. This Object is referred to as the DOM, or Document Object Model.\u003c/p\u003e\n\u003cp\u003eThe DOM is built as a data structure known as a \u0026apos;Tree\u0026apos;, because parent elements have nested children elements (or leaves). As with physical trees, we can follow branches of the tree to get to the exact leaf (or leaves) that we want to access. Each branch of our DOM tree can be it\u0026apos;s own tree. It is important to remember this as we move through this lesson.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://tk-assets.lambdaschool.com/b75e53cc-0f0d-40c3-8f3f-31cc49eab207_dom-tree.jpg\" alt=\"DOM tree\"\u003e\u003c/p\u003e\n\u003cp\u003eWhen the DOM is built and the webpage is loaded, developers get access to it in the form of the global Javascript object \u003ccode\u003edocument\u003c/code\u003e. \u003ccode\u003edocument\u003c/code\u003e contains the entire hierarchy of the page, each element (or DOM node), and it also contains dozens of built in methods and properties. We can use these methods and properties to manipulate what we see on the screen.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNote: There are so many methods and properties on document (and its subsequent elements and collections) that it would take a lot longer to properly cover them all. We will only be covering the few most commonly used. From this point forward you will be expected to reference the official documentation to learn more about the different methods and properties available, when your need arises for something other than what we have taught. This is a very good habit to get into as we progress deeper in to the course.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"follow-along\"\u003eFollow Along\u003c/h2\u003e\n\u003ch3 id=\"dom-investigation\"\u003eDOM Investigation\u003c/h3\u003e\n\u003cp\u003eLets investigate the DOM together by visiting a live website and updating the DOM.  Follow these steps in order:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePrerequisite: This tutorial assumes you are using Google Chrome.  You can get similar results in any other browser but these steps were tailored for a chrome experience.\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eNavigate to \u003ca href=\"https://lambdaschool.com/\"\u003elambdaschool.com\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eRight click on the main heading and you should see a dropdown with an option to \u003ccode\u003einspect element.\u003c/code\u003e Click that option and chrome developer tools should activate.\u003c/li\u003e\n\u003cli\u003eThe developer tools should be showing the selection you made when you right clicked.  Double click the content of the heading.  You should now be able to edit the text of the header.\u003c/li\u003e\n\u003cli\u003eUpdate the text with anything you\u0026apos;d like.  For this example, I will update the text to say \u0026quot;Hello there!\u0026quot;  \u003cem\u003eYou won\u0026apos;t see any changes until you deselect the content in the chrome developer tools.\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eNow try updating the content and HTML of other elements on the page.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNotice that if you refresh the page, the changes you made are gone!  \u003cstrong\u003eThat is because the elements you were editing existed in the DOM and were not permanent!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYou now have experience editing the DOM without writing code.  Go check out the challenge below to see the DOM inside the console!\u003c/p\u003e\n\u003ch2 id=\"challenge\"\u003eChallenge\u003c/h2\u003e\n\u003cp\u003eOpen the console in your web browser and enter \u003ccode\u003econsole.log(document);\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis should make the document appear on the screen, play around with it for a minute. Notice how the document contains all of the HTML elements (otherwise now known as DOM nodes) on the page. Hover over these nodes and notice how the element on the page is highlighted.\u003c/p\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 2 - use DOM selectors, and describe the differences in the behavior of each",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 1,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 1 - DOM I",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/q0orhsemfk\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003ch3 id=\"dom-selectors\"\u003eDOM Selectors\u003c/h3\u003e\n\u003cp\u003eNow that we know how to access the DOM using Javascript, we need a way to select individual elements (or groups of them). Doing so will give us access to all live elements and allow us to manipulate them.\u003c/p\u003e\n\u003cp\u003eTo manipulate elements on the DOM, we need to select them. There are many ways of doing this; for example, we can select the body and the head just by asking for them (document.body, document.head). But, when we want to go deeper, that\u0026apos;s where things get complicated. Thankfully, \u003ccode\u003edocument\u003c/code\u003e has several built-in methods for accessing the exact element(s) we want.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIt is important to note that all of these methods are case sensitive. If you are unsure of the case while using them, please refer to the official documentation.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"getelement-methods\"\u003e\u003ccode\u003egetElement\u003c/code\u003e Methods\u003c/h4\u003e\n\u003cp\u003eThese are the original methods for selecting elements from the DOM. They each take a single string as the only argument, containing either the id or class you are looking for.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003edocument.getElementsByTagName(\u0026apos;p\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis method will take a single string as an argument containing the element name of the elements you want to select. It will return an array-like object called an \u003ccode\u003eHTMLCollection\u003c/code\u003e containing all the elements that contain the element name supplied. We will discuss what a\u003ccode\u003eHTMLCollection\u003c/code\u003e is after we talk about the rest of our selector methods.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003edocument.getElementById(\u0026apos;idName\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis method will take a single string as an argument containing the id of an element, search through the DOM, and return the matching element.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003edocument.getElementsByClassName(\u0026apos;className\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis method will take a single string as an argument containing the class of the elements you want to select. It will return an array-like object called an \u003ccode\u003eHTMLCollection\u003c/code\u003e containing all of the elements that hold the given class.\u003c/p\u003e\n\u003ch4 id=\"queryselector-methods\"\u003e\u003ccode\u003equerySelector\u003c/code\u003e Methods\u003c/h4\u003e\n\u003cp\u003eThese are the newest element selection methods added to the DOM. These methods allow us to select element(s) based on CSS style selectors (remember \u003ccode\u003e.\u003c/code\u003e is class and \u003ccode\u003e#\u003c/code\u003e is id). Each method takes a string containing the selectors and returns the element(s). Note - we can select by element, id, class, or others with both methods.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003edocument.querySelector(\u0026apos;.custom-style\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis method will search for and return the \u003cstrong\u003efirst element\u003c/strong\u003e that matches the value passed into the method. Remember from above that the biggest change from the older DOM selection methods is that we now need to pass the proper CSS selector into the argument.\u003c/p\u003e\n\u003cp\u003eIf we passed \u003ccode\u003e(\u0026apos;custom-style\u0026apos;)\u003c/code\u003e and not \u003ccode\u003e(\u0026apos;.custom-style\u0026apos;)\u003c/code\u003e we would error out.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003edocument.querySelectorAll(\u0026apos;queryString\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis method will search for and return \u003cem\u003eALL\u003c/em\u003e elements matching the query string. This method returns these elements in an array-like object called a \u003ccode\u003eNodeList\u003c/code\u003e\u003c/p\u003e\n\u003ch4 id=\"the-difference-between-htmlcollection-nodelist-and-array\"\u003eThe Difference between \u003ccode\u003eHTMLCollection\u003c/code\u003e, \u003ccode\u003eNodeList\u003c/code\u003e, and \u003ccode\u003eArray\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eWhen we use \u003ccode\u003egetElementsByClassName()\u003c/code\u003e or \u003ccode\u003equerySelectorAll()\u003c/code\u003e we get back either an \u003ccode\u003eHTMLCollection\u003c/code\u003e or a \u003ccode\u003eNodeList\u003c/code\u003e respectively. We refer these to as \u0026apos;array-like objects.\u0026apos; We have seen an array-like object before (the \u003ccode\u003earguments\u003c/code\u003e object in a function). They both have numerical zero-based indices and the length property, but that is all they share with an Array. \u003ccode\u003eNodeList\u003c/code\u003e does take it one step further, and has access to \u003ccode\u003e.forEach\u003c/code\u003e. There are no \u003ccode\u003e.reduce\u003c/code\u003e or \u003ccode\u003e.map\u003c/code\u003e or any other array method.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePro tip:\u003c/strong\u003e The \u003ccode\u003eArray\u003c/code\u003e class contains a method we can use to create an array from an array-like object, called \u003ccode\u003e.from()\u003c/code\u003e. To use this, we would give \u003ccode\u003e.from\u003c/code\u003e the array-like object as its only argument.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003eArray.from(arrayLikeObject)\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"follow-along\"\u003eFollow Along\u003c/h2\u003e\n\u003ch3 id=\"selector-tutorial\"\u003eSelector Tutorial\u003c/h3\u003e\n\u003cp\u003eLet\u0026apos;s get some practice using different selector methods. You can use \u003ca href=\"https://codepen.io/lambdaschool/pen/eLaXXb?editors=1010\"\u003ethis code\u003c/a\u003e or write your own.\u003c/p\u003e\n\u003cp\u003eStudy this HTML first:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"html language-html\"\u003e \u0026lt;header\u0026gt;\n    \u0026lt;h1 class=\u0026quot;main-header\u0026quot;\u0026gt;Selectors!\u0026lt;/h1\u0026gt;\n    \u0026lt;nav class=\u0026quot;main-nav\u0026quot;\u0026gt;\n      \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;Home\u0026lt;/a\u0026gt;\n      \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;About\u0026lt;/a\u0026gt;\n      \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;Blog\u0026lt;/a\u0026gt;\n      \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;Contact\u0026lt;/a\u0026gt;\n    \u0026lt;/nav\u0026gt;\n  \u0026lt;/header\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"queryselector\"\u003e\u003ccode\u003equerySelector()\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eWhat if we wanted to select all the first \u003ccode\u003ea\u003c/code\u003e tags within our navigation? There are several ways to accomplish this task, but let\u0026apos;s use \u003ccode\u003equerySelector()\u003c/code\u003e to get started.\u003c/p\u003e\n\u003cp\u003eWhen working with the DOM, we may want to re-use the reference several times in our code. Let\u0026apos;s declare a \u003ccode\u003econst\u003c/code\u003e to hold our DOM reference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst mySelection = document.querySelector(\u0026apos;a\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice we had to use \u003ccode\u003edocument\u003c/code\u003e in front of \u003ccode\u003equerySelector()\u003c/code\u003e that is because querySelector is a method of the document object.\u003c/p\u003e\n\u003cp\u003eNext, let\u0026apos;s log the result of our selection.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst mySelection = document.querySelector(\u0026apos;a\u0026apos;);\nconsole.log(mySelection);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe should see this log in the console:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003e\u0026quot;\u0026lt;a href=\u0026apos;#\u0026apos; class=\u0026apos;nav-item\u0026apos;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026quot;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe now have access to that element node in the DOM! What if we wanted to select multiple elements at once? We have just the method for that: \u003ccode\u003equerySelectorAll()\u003c/code\u003e.\u003c/p\u003e\n\u003ch4 id=\"queryselectorall\"\u003e\u003ccode\u003equerySelectorAll()\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eIf you recall from the introduction to selectors, \u003ccode\u003equerySelectorAll()\u003c/code\u003e will allow us to return an array-like object called a \u003ccode\u003eNodeList\u003c/code\u003e. Let\u0026apos;s set up a new const for our new selection:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst multipleSelections = document.querySelectorAll(\u0026apos;a\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that all we changed on the right side of the operator was adding an \u0026quot;All\u0026quot; to \u0026quot;querySelector.\u0026quot; The returned value is very different though, check your console\u0026apos;s log to see what happened. If you are using chrome developer tools, you will see something like this in your console:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003eNodeList(4)\n  0: a.nav-item\n  1: a.nav-item\n  2: a.nav-item\n  3: a.nav-item\n  length: 4\n  __proto__: NodeList\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWow, that is totally different than our result from \u003ccode\u003equerySelector()\u003c/code\u003e in the first example! We now have a \u003ccode\u003eNodeList\u003c/code\u003e and all of the nodes matching the \u003ccode\u003ea\u003c/code\u003e elements.\u003c/p\u003e\n\u003cp\u003eWhat can we do with a \u003ccode\u003eNodeList\u003c/code\u003e? You can \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/NodeList\"\u003edig deeper into the documentation\u003c/a\u003e, but for our tutorial, let\u0026apos;s see how it is \u0026quot;array-like.\u0026quot;\u003c/p\u003e\n\u003cp\u003eStudy this code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst multipleSelections = document.querySelectorAll(\u0026apos;a\u0026apos;);\nconsole.log(multipleSelections[2]);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice the \u003ccode\u003emultipleSelections[2]\u003c/code\u003e. That looks very similar to how we can use indices in arrays. The log result from the code above should read as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003e\u0026quot;\u0026lt;a href=\u0026apos;#\u0026apos; class=\u0026apos;nav-item\u0026apos;\u0026gt;Blog\u0026lt;/a\u0026gt;\u0026quot;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBeing able to access elements in this way is extremely powerful and will allow you to be creative if an HTML solution is not possible. Imagine you didn\u0026apos;t have a class or ID to hook into, you could use the \u003ccode\u003eNodeList\u003c/code\u003e index to get the job done!\u003c/p\u003e\n\u003ch4 id=\"dont-forget-the-selector\"\u003eDon\u0026apos;t Forget The Selector\u003c/h4\u003e\n\u003cp\u003eWhen using \u003ccode\u003equerySelectorAll()\u003c/code\u003e don\u0026apos;t forget it requires you to use the proper CSS selector. Using the same HTML example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"html language-html\"\u003e\u0026lt;header\u0026gt;\n  \u0026lt;h1 class=\u0026quot;main-header\u0026quot;\u0026gt;Selectors!\u0026lt;/h1\u0026gt;\n  \u0026lt;nav class=\u0026quot;main-nav\u0026quot;\u0026gt;\n    \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;Home\u0026lt;/a\u0026gt;\n    \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;About\u0026lt;/a\u0026gt;\n    \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;Blog\u0026lt;/a\u0026gt;\n    \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;Contact\u0026lt;/a\u0026gt;\n  \u0026lt;/nav\u0026gt;\n\u0026lt;/header\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUse querySelectorAll() to select all the \u003ccode\u003enav-item\u003c/code\u003e classes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst multipleClasses = document.querySelectorAll(\u0026apos;.nav-item\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that we had to type out the \u003ccode\u003e.\u003c/code\u003e in \u003ccode\u003e.nav-item\u003c/code\u003e. This trips up new developers to JavaScript all the time. If you were to log out the results of this session, you would see it\u0026apos;s just a \u003ccode\u003eNodeList\u003c/code\u003e like before, but now it\u0026apos;s using classes instead of the \u003ccode\u003ea\u003c/code\u003e element. Push yourself further by using the challenge below!\u003c/p\u003e\n\u003ch2 id=\"challenge\"\u003eChallenge\u003c/h2\u003e\n\u003cp\u003eFinish the DOM selector requests based on given HTML, LESS, and JS \u003ca href=\"https://codepen.io/lambdaschool/pen/mGYarw?editors=1010\"\u003e- follow this link for the challenge.\u003c/a\u003e\u003c/p\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 3 - use different properties and methods to manipulate a selected element",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 1,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 1 - DOM I",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/vruue7h0zh\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eNow that we have access to element(s), we can start to manipulate them and change their characteristics from the original html.\u003c/p\u003e\n\u003cp\u003eAfter we have captured our element (eg. \u003ccode\u003econst el = document.querySelector(\u0026apos;#idName\u0026apos;);\u003c/code\u003e we can use that instance of the element we selected to access and assign values to properties natively contained on it. Once again, there are dozens of properties and methods given to us on each element. Here are a few of the most commonly used properties:\u003c/p\u003e\n\u003ch4 id=\"textcontent\"\u003e.textContent\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eGets and sets the text of an element. Essentially whatever text is between the open and closing tags of an HTML element.\u003c/li\u003e\n\u003cli\u003eCan use the assignment operator ( = ) to reset the text of an element\u003c/li\u003e\n\u003cli\u003eSetting this property on a node removes all of its children and replaces them with the new single text node.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;div\u0026gt;Something Here\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eelement.textContent = \u0026apos;Something New\u003c/code\u003e;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"setattribute-or-attr\"\u003e.setAttribute() (or .{attr})\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eThis method (or property) is used as a way to set or reassign an attribute on the element.\u003c/li\u003e\n\u003cli\u003e\u0026apos;.setAttribute()\u0026apos; is a method that takes two arguments, the attribute to set, and the value to set to that attribute.\u003c/li\u003e\n\u003cli\u003eeg: \u003ccode\u003eelement.setAttribute(\u0026apos;src\u0026apos;, \u0026apos;http://www.imagsource.com/image.jpg\u0026apos;)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eCan also use the pattern: \u003ccode\u003eelement.\u0026apos;attrName\u0026apos; = \u0026apos;value\u0026apos;\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eeg: \u003ccode\u003eelement.src = \u0026apos;http://www.imagsource.com/image.jpg\u0026apos;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"style\"\u003e.style\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eEvery element contains a style object. This property accesses that style object. The style object contains every available style as a key and a value as the value. It is important to note, that these are NOT the CSS styles, these are inline HTML styles.\u003c/li\u003e\n\u003cli\u003eThese styles are associated with the HTML inline style set on the element\u003cul\u003e\n\u003cli\u003eeg: \u003ccode\u003e\u0026lt;div style=\u0026quot;color: red;\u0026quot;\u0026gt;DIV STUFF\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003eYou can access and change a property on the style object by using the assignment operator \u003ccode\u003e=\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eeg: \u003ccode\u003eelement.style.color = \u0026apos;blue\u0026apos;;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eChanging a property on the style object will effectively give this element an inline style.\u003c/li\u003e\n\u003cli\u003eInline styles have the highest specificity, overriding any other selector except \u003ccode\u003e!important\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eVERY IMPORTANT to note that this does NOT access or change anything in the CSS file.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"classname-id\"\u003e.className, .id\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e.className\u003c/code\u003e accesses or assigns a string containing all of the classes on the element.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.id\u003c/code\u003e accesses or assigns a string containing the id of the element.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"classlist\"\u003e.classList\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eclassList\u003c/code\u003e will return an array-like object of all the classes on the element. There are many useful methods available on \u003ccode\u003eclassList\u003c/code\u003e.\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eclassList\u003c/code\u003e is a \u003ccode\u003eDOMTokenList\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eA \u003ccode\u003eDOMTokenList\u003c/code\u003e is an array-like object with a numerical zero-based index, a length property, also the \u003ccode\u003e.contains()\u003c/code\u003e and \u003ccode\u003e.forEach()\u003c/code\u003e methods.\u003c/li\u003e\n\u003cli\u003eMost notably the methods \u003ccode\u003e.add()\u003c/code\u003e \u003ccode\u003e.remove()\u003c/code\u003e and \u003ccode\u003e.toggle()\u003c/code\u003e exist. All three take a single string representing the class.\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e.add(\u0026apos;className\u0026apos;)\u003c/code\u003e and \u003ccode\u003e.remove(\u0026apos;className\u0026apos;)\u003c/code\u003e do as their names indicate.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.toggle(\u0026apos;className\u0026apos;)\u003c/code\u003e will add the class if it does not exist and remove it if if does.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"appendchild-and-prepend\"\u003e.appendChild() and .prepend()\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eThese methods add child elements to parent elements.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.appendChild(child)\u003c/code\u003e will take an element and add it to it\u0026apos;s children. It will add it to the \u0026apos;end\u0026apos; physically so if the children are displayed in order it will be the last.\u003cul\u003e\n\u003cli\u003eeg: \u003ccode\u003eparentElement.appendChild(childElement)\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.prepend(child)\u003c/code\u003e adds a child to the beginning, displaying it first.\u003cul\u003e\n\u003cli\u003eeq:  \u003ccode\u003eparentElement.prepend(childElement)\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"children-and-parentnode\"\u003e.children and .parentNode\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eThese properties are used for accessing relatives of the element.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.children\u003c/code\u003e returns an \u003ccode\u003eHTMLCollection\u003c/code\u003e of all the children of that element.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.parentNode\u003c/code\u003e returns the parent element of that element.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"follow-along\"\u003eFollow Along\u003c/h2\u003e\n\u003ch3 id=\"dom-manipulation-tutorial\"\u003eDOM Manipulation Tutorial\u003c/h3\u003e\n\u003cp\u003eLet\u0026apos;s get some practice manipulating the DOM.  You can use \u003ca href=\"https://codepen.io/lambdaschool/pen/jvjjGB?editors=1011\"\u003ethis code as a base for your JavaScript\u003c/a\u003e or write your own HTML and CSS along the way.\u003c/p\u003e\n\u003ch4 id=\"updating-text\"\u003eUpdating Text\u003c/h4\u003e\n\u003cp\u003eWhen we want to update the text using the DOM, the go-to property is called \u003ccode\u003etextContent\u003c/code\u003e.  We can both read and write text inside of elements using \u003ccode\u003etextContent\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eGiven this HTML, lets make some updates to the text:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"html language-html\"\u003e\u0026lt;h2 class=\u0026quot;second-heading\u0026quot;\u0026gt;I am the DOM\u0026lt;/h2\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFirst, lets set up a reference to our element on the DOM:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003e  const secondHeading = document.querySelector(\u0026apos;.second-heading\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe are now prepared to update the content of our heading.  Let\u0026apos;s update the content to say \u0026quot;DOM updated!\u0026quot;\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003e  secondHeading.textContent = \u0026quot;DOM updated!\u0026quot;;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that we are first getting the text node of the element and then setting a new value!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSecurity Note\u003c/strong\u003e You may read about \u003ccode\u003einnerHTML\u003c/code\u003e in your DOM learning. Avoid using \u003ccode\u003einnerHTML\u003c/code\u003e as it could potentially be used as an attack vector for cross site attacks.\u003c/p\u003e\n\u003ch2 id=\"updating-attributes\"\u003eUpdating Attributes\u003c/h2\u003e\n\u003cp\u003eUpdating HTML attributes is vital to DOM manipulation.  Let\u0026apos;s update the style for the \u003ccode\u003eh1\u003c/code\u003e in the code below.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"html language-html\"\u003e\u0026lt;header\u0026gt;\n  \u0026lt;h1 class=\u0026quot;main-header\u0026quot;\u0026gt;Dom Manipulation\u0026lt;/h1\u0026gt;\n  \u0026lt;nav class=\u0026quot;main-nav\u0026quot;\u0026gt;\n    \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;Home\u0026lt;/a\u0026gt;\n    \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;About\u0026lt;/a\u0026gt;\n    \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;Blog\u0026lt;/a\u0026gt;\n    \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;nav-item\u0026quot;\u0026gt;Contact\u0026lt;/a\u0026gt;\n  \u0026lt;/nav\u0026gt;\n\u0026lt;/header\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUpdating the DOM usually happens in two steps:\u003c/p\u003e\n\u003ch3 id=\"step-1-select-the-element\"\u003eStep 1: Select the element\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst mainHeader = document.querySelector(\u0026apos;.main-header\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"step-2-use-the-desired-attribute-property-to-update-the-element\"\u003eStep 2: Use the desired attribute property to update the element\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003emainHeader.style.color = \u0026apos;red\u0026apos;;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can even chain the two steps together like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst mainHeader = document.querySelector(\u0026apos;.main-header\u0026apos;).style.color = \u0026apos;red\u0026apos;;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis two-step process can be repeated for other attributes as well!  What if we had an empty \u003ccode\u003esrc\u003c/code\u003e attribute on an image tag?  Let\u0026apos;s try it out provided we have this HTML:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"html language-html\"\u003e\u0026lt;img class=\u0026quot;custom-img\u0026quot; src=\u0026quot;\u0026quot; alt=\u0026quot;Kitty image\u0026quot; /\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSelect the image element\u0026apos;s class and update the \u003ccode\u003esrc\u003c/code\u003e attribute with this link:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehttps://images.pexels.com/photos/20787/pexels-photo.jpg?auto=compress\u0026amp;cs=tinysrgb\u0026amp;h=350\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst customImg = document.querySelector(\u0026apos;.custom-img\u0026apos;);\n\ncustomImg.src = \u0026apos;https://images.pexels.com/photos/20787/pexels-photo.jpg?auto=compress\u0026amp;cs=tinysrgb\u0026amp;h=350\u0026apos;;\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"javascript-css-syntax\"\u003eJavaScript CSS Syntax\u003c/h3\u003e\n\u003cp\u003eWhen using JavaScript to update CSS style properties, we need to be careful to remember that JavaScript does not accept dashes as a valid naming value!  Whenever a CSS property contains a dash, we must use camel casing in JavaScript.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"css language-css\"\u003e.some-class {\n  background-color: gray;\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe JavaScript version would look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003e  const someClass = document.querySelector(\u0026apos;.some-class\u0026apos;);\n\n  someClass.style.backgroundColor = \u0026quot;gray\u0026quot;;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePro Tip:\u003c/strong\u003e Don\u0026apos;t forget the string when you assign a value to a CSS property.\u003c/p\u003e\n\u003ch2 id=\"challenge\"\u003eChallenge\u003c/h2\u003e\n\u003ch3 id=\"dom-manipulation-challenge\"\u003eDOM Manipulation Challenge\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://codepen.io/lambdaschool/pen/jvjjGB?editors=1011\"\u003eTake the example code from your tutorial\u003c/a\u003e and try updating the DOM in various ways.\u003c/p\u003e\n\u003cp\u003eHere are some ideas:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChange the color of the paragraphs\u003c/li\u003e\n\u003cli\u003eChange the text contents of any element of your choosing\u003c/li\u003e\n\u003cli\u003eChange the \u003ccode\u003ehref\u003c/code\u003e of an anchor tag\u003c/li\u003e\n\u003cli\u003eUpdate the \u003ccode\u003ealt\u003c/code\u003e tag of an image\u003c/li\u003e\n\u003cli\u003eUpdate layout styles, try out flex properties with JavaScript syntax\u003c/li\u003e\n\u003c/ul\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 4 - create a new element, manipulate it, and add it to the DOM",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 1,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 1 - DOM I",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/q66qu8ziiw\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eAn important feature of the DOM is the ability to create brand new elements dynamically. Using the \u003ccode\u003edocument.createElement()\u003c/code\u003e method, we will be able to create a brand new element, style it, and add it anywhere on the DOM we would like.\u003c/p\u003e\n\u003ch2 id=\"follow-along\"\u003eFollow Along\u003c/h2\u003e\n\u003ch3 id=\"createelement\"\u003e.createElement\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e.createElement\u003c/code\u003e creates a brand new element based on a given string.\u003c/li\u003e\n\u003cli\u003eNew element exists in memory, but not on the DOM yet.\u003c/li\u003e\n\u003cli\u003eCan use any DOM property or method to style and manipulate the element.\u003c/li\u003e\n\u003cli\u003eeg: \u003ccode\u003edocument.createElement(\u0026apos;h1\u0026apos;)\u003c/code\u003e will create an \u003ccode\u003eh1\u003c/code\u003e element.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"appendchild-and-prepend\"\u003e.appendChild() and .prepend()\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAdd child elements to parent elements.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.appendChild(child)\u003c/code\u003e add an element to it\u0026apos;s children. Adds to the \u0026apos;end\u0026apos;,  so that if displayed in order, the added child will be last.\u003cul\u003e\n\u003cli\u003eeg: \u003ccode\u003eparentElement.appendChild(childElement)\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.prepend(child)\u003c/code\u003e adds a child to the beginning, displaying it first.\u003cul\u003e\n\u003cli\u003eeq:  \u003ccode\u003eparentElement.prepend(childElement)\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"challenge\"\u003eChallenge\u003c/h2\u003e\n\u003cp\u003ePractice the concepts covered.\u003c/p\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Module 2 Class Recordings",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 2,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 2 - DOM II",
              "isHomePage": false,
              "html": "\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/iXgoHYWJRBI\"\u003eWeb FT36 w/ Gabriel Cabrejas\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/6oDYvbUUHXo\"\u003eWeb PT22 w/ Keiran Kozlowski\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/FhozK2bwTV8\"\u003eWeb PT21 w/ Emily Seibert\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/Io8k-9Ozy8Y\"\u003eWeb PT18 w/ Keiran Kozolwski\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/Yar3Llxhifs\"\u003eWeb PT16 w/ Dan Frehner\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 1 - install Node on Mac (if needed)",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 2,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 2 - DOM II",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/s9te7mjbtc\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eIn preprocessing, there are three main concepts we need to understand:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe language or syntax that we use to write our code (LESS)\u003c/li\u003e\n\u003cli\u003eThe compiler that converts the language (Node)\u003c/li\u003e\n\u003cli\u003eThe CSS output from the compiler (Normal CSS)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis module focuses on the compiler.  For us to use our language (LESS), we need to have a compiler that understands that specific language input.  \u003c/p\u003e\n\u003cp\u003eA compiler is a program that converts language into code.  In our case, LESS is the language, and CSS is the outputted code.  We utilize compilers to provide more features than standard CSS can offer.  \u003c/p\u003e\n\u003ch2 id=\"follow-along\"\u003eFollow Along\u003c/h2\u003e\n\u003cp\u003eInstalling our working environment can be daunting at first.  We will be covering a lot of ground.  Get through each step before going back and trying to learn everything you did.  \u003c/p\u003e\n\u003cp\u003eIf you are on a mac, follow the mac instructions below.  If you are on a PC, scroll down after the mac instructions to the PC instructions.  If you are on Linux, chances are Node is already installed in your system. Run \u003ccode\u003enode -v\u003c/code\u003e in a shell to make sure, and then you can look at step 3 in the mac instructions.\u003c/p\u003e\n\u003ch3 id=\"step-by-step-install-instructions-for-mac\"\u003eStep By Step Install Instructions for Mac\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eStep 1: \u003ca href=\"https://brew.sh/\"\u003eInstall Homebrew and Node\u003c/a\u003e\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFollow the instructions on how to install Homebrew using your terminal\u003c/li\u003e\n\u003cli\u003ePay attention to your terminal as the installer will ask for a password\u003c/li\u003e\n\u003cli\u003eOnce Homebrew is installed, run \u003ccode\u003ebrew install node\u003c/code\u003e in your terminal\u003c/li\u003e\n\u003cli\u003ePay attention to your terminal, as there might be small issues to troubleshoot\u003c/li\u003e\n\u003cli\u003eRestart your terminal after installation\u003c/li\u003e\n\u003cli\u003eRun \u003ccode\u003enode -v\u003c/code\u003e in your terminal to make sure node was installed correctly\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eStep 2: Install Less\u003c/em\u003e\u003c/strong\u003e\u003cbr\u003e\n\u003cem\u003eNOTE:\u003c/em\u003e You will see our commands have \u003ccode\u003e-g\u003c/code\u003e in them. Please write the commands exactly as you see them. Globally installing packages is ideal for our situation.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOpen terminal and run \u003ccode\u003enpm install -g less\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eIf it\u0026apos;s not working, restart your terminal and try again\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eStep 3: Install less-watch-compiler\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOpen the terminal and run \u003ccode\u003enpm install -g less-watch-compiler\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eStep 4: Use less-watch-compiler On Your Project\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFork and clone \u003ca href=\"https://github.com/LambdaSchool/Preprocessing-Part-I\"\u003ePreprocessing-Part-I\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecd\u003c/code\u003e into your project on your local machine\u003c/li\u003e\n\u003cli\u003eOnce you are in the root of your project run \u003ccode\u003eless-watch-compiler less css index.less\u003c/code\u003e \u003c/li\u003e\n\u003cli\u003eYour project should be up and running, change some styles around in your .less file, and save the file to make sure you see a change in your CSS.\u003c/li\u003e\n\u003cli\u003eGreat work, you\u0026apos;re all set up!\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"step-by-step-install-instructions-for-pc\"\u003eStep By Step Install Instructions for PC\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eStep 1: \u003ca href=\"https://nodejs.org/en/\"\u003eInstall Node.js\u003c/a\u003e\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eStep 2: \u003ca href=\"https://git-scm.com/download/win\"\u003eInstall Git Bash (Git SCM)\u003c/a\u003e\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAfter the installer finishes, open git bash and run \u003ccode\u003enode -v\u003c/code\u003e to make sure node is installed correctly\u003c/li\u003e\n\u003cli\u003eIf you don\u0026apos;t see some node version numbers display in your git bash window, restart git bash and try again\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eStep 3: Install Less\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNOTE:\u003c/em\u003e You will see our commands have \u003ccode\u003e-g\u003c/code\u003e in them. Please write the commands exactly as you see them. Globally installing packages is ideal for our situation.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOpen git bash and run \u003ccode\u003enpm install -g less\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eIf it\u0026apos;s not working, restart your git bash and try again\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eStep 4: Install less-watch-compiler\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOpen git bash and run \u003ccode\u003enpm install -g less-watch-compiler\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eStep 5: Use less-watch-compiler On Your Project\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFork and clone \u003ca href=\"https://github.com/LambdaSchool/Preprocessing-Part-I\"\u003ePreprocessing-Part-I\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecd\u003c/code\u003e into your project on your local machine\u003c/li\u003e\n\u003cli\u003eOnce you are in the root of your project run \u003ccode\u003eless-watch-compiler less css index.less\u003c/code\u003e \u003c/li\u003e\n\u003cli\u003eYour project should be up and running, change some styles around in your .less file, and save the file to make sure you see a change in your CSS.\u003c/li\u003e\n\u003cli\u003eGreat work, you\u0026apos;re all set up!\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"challenge\"\u003eChallenge\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eFollow the instructions provided to you in the tutorial above.\u003c/li\u003e\n\u003cli\u003eOnce in your project, change the background color of your body tag to \u003ccode\u003ered\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eOnce the background turns red, your compiler is working correctly.\u003c/li\u003e\n\u003c/ol\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 2 -install Node on Windows (if needed)",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 2,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 2 - DOM II",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/dq31jsdein\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003c!---##Overview---\u003e\n\u003c!---##Follow Along---\u003e\n\u003c!---##Challenge---\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 3 - explain what events are in the browser window, and how event listeners can listen for those events.",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 2,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 2 - DOM II",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/psrcnzxk0l\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eWe use Javascript to make our pages dynamic and usable. Now that we can access and manipulate elements on our page, you might be wondering to yourself, \u0026quot;Why don\u0026apos;t we just change the elements in the HTML file directly? Why do we have to go through all of this just to change some styling on an element?\u0026quot; Those are valid questions, and the way we have been using Javascript so far, it would make sense to change our HTML instead.\u003c/p\u003e\n\u003cp\u003eBut, Javascript\u0026apos;s real power lies in its ability to make webpages interactive. In addition to manipulating elements, Javascript also allows us to add features and make modifications to our site by directly reacting to user interactions. Think about a button click, drag and drop, zoom, or any number of user interactions. We create functionality for those interactions using JavaScript. Now that we know how to manipulate and modify DOM nodes, we can learn about events.\u003c/p\u003e\n\u003cp\u003eEvery user interaction with a site is an event: a click, moving the mouse, scrolling the page, pressing a key on the keyboard, these are all events on the page, and the browser can detect all of them. There are tons of different events the browser tracks. When an event happens on a page, it is known as a trigger.\u003c/p\u003e\n\u003cp\u003eNow that we know what an event is and we know the browser is always tracking them, we need to be able to listen for specific events on specific elements. Did a user click that button? Did a users mouse hover over an element? Was there text entered into the input field? There are dozens of events an element can listen for. When one of those events happens on that element, we can do something about it. The tracking process and subsequent action taken is called an event listener. We put an event listener on an element and give it a callback. When that event is triggered on the element, the callback is run.\u003c/p\u003e\n\u003c!---##Follow Along---\u003e\n\u003c!---##Challenge---\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 4 - add event listeners and event handlers to elements",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 2,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 2 - DOM II",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/shtn02rjnt\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003ch3 id=\"addeventlistener\"\u003e.addEventListener\u003c/h3\u003e\n\u003cp\u003eOnce we have an element selected, we can use the \u0026apos;.addEventListener\u0026apos; method on that element. \u003ccode\u003e.addEventListener\u003c/code\u003e takes two arguments, first the event to listen for and, second, the callback to fire when that event is triggered. For a complete list of events see the resources below. In use, this looks something like \u003ccode\u003eelement.addEventListener(\u0026apos;click\u0026apos;, callback);\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"events\"\u003eEvents\u003c/h3\u003e\n\u003cp\u003eWe learned before that there are different types of events we can listen for. The most common are mouse events highlighted by the \u0026apos;click\u0026apos; event, but there are dozens of more events we can listen for. We can add event listeners for as many events as there are for each element, meaning we can listen for a \u003ccode\u003emouseclick\u003c/code\u003e, \u003ccode\u003ekeypress\u003c/code\u003e, \u003ccode\u003ehover\u003c/code\u003e, and more all on the same element. Although to do so we need to call \u003ccode\u003e.addEventListener\u003c/code\u003e and pass in a callback for each one.\u003c/p\u003e\n\u003cp\u003eTake 5 minutes and study this MDN page. Choose an event that is NOT a mouse event, and read about it and how it works.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/Events\"\u003eMDN Event Listeners\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"the-callback-and-the-event-object\"\u003eThe callback and the \u003ccode\u003eEvent Object\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eThe callback (also known as an event handler) will take a single argument; this is known as the \u003ccode\u003eEvent Object\u003c/code\u003e. This is a Javascript Object and contains all we need to know about the event and the element it happened on. \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eeg: \u003ccode\u003eelement.addEventListener(\u0026apos;click\u0026apos;, (event) =\u0026gt; {//Handle event});\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eOne of the most important properties of the event object is \u003ccode\u003e.target\u003c/code\u003e, this property will give us all of the info about the DOM node where the event happened. It has many of the same properties as a regular DOM node, \u003ccode\u003e.children\u003c/code\u003e, \u003ccode\u003e.parent\u003c/code\u003e, \u003ccode\u003e.style\u003c/code\u003e, \u003ccode\u003einnerText\u003c/code\u003e, etc. We can use these properties to manipulate the element itself, or it\u0026apos;s relatives. \u003c/li\u003e\n\u003cli\u003eWe can use this to manipulate the target in any way we want, for example to change the background color we would write the following: \u003ccode\u003eelement.addEventListener(\u0026apos;click\u0026apos;, (event) =\u0026gt; { event.target.style.backgroundColor = \u0026apos;blue\u0026apos;; });\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eDepending on the type of event listened for, we can have access to other information about the event as well, such as the key pressed (in the form of a code) and other things. Spend 5 minutes reading about the event object here: \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event#Properties\"\u003eMDN Event Object: Properties\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!---##Follow Along---\u003e\n\u003ch2 id=\"challenge\"\u003eChallenge\u003c/h2\u003e\n\u003cp\u003eFollow the instructions in the Javascript section of this codepen on your own. Use the \u003ccode\u003esampleButton\u003c/code\u003e element at the top as a reference, and add the appropriate event listeners to the elements.  Please Fork and save your code, and share it with your TL.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://codepen.io/lambdaschool/pen/gqmrwx?editors=0010\"\u003eCodepen: DOM-II Events\u003c/a\u003e\u003c/p\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 5 - recognize event propagation and the method used to prevent it",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 2,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 2 - DOM II",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/4gxn61w9au\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThink of a pyramid. Pyramids are made up of many layers, the bottom layer is the largest and as it goes higher, ever decreasing sized layers are added to the one before it. If you are standing on the uppermost layer of a pyramid, you are also standing on every layer below it.  When we look at a DOM tree we can see those child elements are nested inside parent elements, like a pyramid. And, like a pyramid, if you stand(trigger an event) on a child element, you are also triggering that same event on every parent element all the way up to the body. This process is called event propagation. If you have an event of the same type on a parent element and a child element, and you trigger that event on the child element, it will also trigger on the parent. We have to be careful not to create unwanted interactions because of this. In the future, you may consider this is a feature, for now, this is something we would like to avoid.\u003c/p\u003e\n\u003cp\u003eIn our event handler, we are passed the event object. The event object has lots of methods and properties on it including one called \u003ccode\u003e.stopPropagation()\u003c/code\u003e if we call this method in our event handler, it will effectively stop our event from bubbling any further up the chain. \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eeg: \u003ccode\u003econst eventHandler = (event) =\u0026gt; { event.stopPropagation() };\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"preventdefault\"\u003e.preventDefault\u003c/h4\u003e\n\u003cp\u003eSome elements have a native default reaction to certain events. For example, form elements will refresh the page on submit.  \u003ccode\u003e.preventDefault\u003c/code\u003e is a method on the event object, and it will stop an HTML element from reacting in its default way. \u003ccode\u003e.preventDefault\u003c/code\u003e will be used less than \u003ccode\u003e.stopPropagation\u003c/code\u003e, but it is important to know about as well.\u003c/p\u003e\n\u003c!---##Follow Along---\u003e\n\u003ch2 id=\"challenge\"\u003eChallenge\u003c/h2\u003e\n\u003cp\u003eGo back to the codepen you were working on. And complete steps 9 - 12.\u003c/p\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Module 3 Class Recordings",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 3,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 3 - Components I",
              "isHomePage": false,
              "html": "\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/yyAS8K_EcM8\"\u003eWeb FT36 w/ Gabriel Cabrejas\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/X0ZQ4QNdyyo\"\u003eWeb PT19 w/ Emily Seibert\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/0piuGvzoEQQ\"\u003eWeb PT18 w/Keiran Kozlowski\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/mAnvvOhz_oA\"\u003eWEB PT16 w/ Dan Frehner\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/-jnp9FxCsYU\"\u003eWEB PT15 w/ Emily Seibert\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 1 - describe what a component is and identify different parts of a component",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 3,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 3 - Components I",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/zfuvchtxn3\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003ch3 id=\"components\"\u003eComponents\u003c/h3\u003e\n\u003cp\u003eA component is made of several parts: HTML, CSS, or JavaScript brought together for reuse in a website or application.\u003c/p\u003e\n\u003ch4 id=\"components---html\"\u003eComponents - HTML:\u003c/h4\u003e\n\u003cp\u003eWhen building HTML with a component mentality, you need to ask the question: \u0026quot;What am I trying to display from my data?\u0026quot;\u003c/p\u003e\n\u003cp\u003eBecause we are focused on user interface concepts, we don\u0026apos;t need to access a database at this point. For us, static HTML is data, since it is, after all, what we\u0026apos;re trying to display.\u003c/p\u003e\n\u003cp\u003eReview the following code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"html language-html\"\u003e\u0026lt;div class=\u0026quot;custom-buttons\u0026quot;\u0026gt;\n  \u0026lt;button\u0026gt;Button 1\u0026lt;/button\u0026gt;\n  \u0026lt;button\u0026gt;Button 2\u0026lt;/button\u0026gt;\n  \u0026lt;button\u0026gt;Button 3\u0026lt;/button\u0026gt;\n  \u0026lt;button\u0026gt;Button 4\u0026lt;/button\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice we have repeating \u003ccode\u003e\u0026lt;button\u0026gt;\u0026lt;/button\u0026gt;\u003c/code\u003e tags.  This is an opportunity for us to think about how we could use our CSS and JavaScript to create multiple buttons regardless of how many buttons we have to work with.  The HTML gives us a great starting point for a button component, but we need to style it for reuse.\u003c/p\u003e\n\u003ch3 id=\"components---css\"\u003eComponents - CSS:\u003c/h3\u003e\n\u003cp\u003eWriting CSS for components is more about rationale than syntax.  Components should be modular or stand-alone.  With that in mind, you should try to think of your component CSS in a way that could be moved around at any moment and not reliant on any other styles being in place.\u003c/p\u003e\n\u003cp\u003eOne way that can help you control your styles is to use a specificity chain that only matches up with your component.  You could use a specific class name to accomplish this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"html language-html\"\u003e\u0026lt;div class=\u0026quot;custom-buttons\u0026quot;\u0026gt;\n  \u0026lt;button class=\u0026quot;custom-btn\u0026quot;\u0026gt;Button 1\u0026lt;/button\u0026gt;\n  \u0026lt;button class=\u0026quot;custom-btn\u0026quot;\u0026gt;Button 2\u0026lt;/button\u0026gt;\n  \u0026lt;button class=\u0026quot;custom-btn\u0026quot;\u0026gt;Button 3\u0026lt;/button\u0026gt;\n  \u0026lt;button class=\u0026quot;custom-btn\u0026quot;\u0026gt;Button 4\u0026lt;/button\u0026gt;\n\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eNaming conventions vary wildly in the work place. The recommendation is to adjust to the standards decided on by your employer.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIf you\u0026apos;re using a preprocessor, a common practice is to have your preprocessed file named after the component.  You could then import your component name into the main file.  Here is an example of the import you could use and then what the file could look like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"less language-less\"\u003e@import custom-btn.less\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"less language-less\"\u003e.custom-btn {\n  // custom styles here\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou may be thinking, \u0026quot;wait, that\u0026apos;s it?\u0026quot; Yep! Using components is as simple as building styles so that they don\u0026apos;t rely on any other element on the page and don\u0026apos;t bleed over into another component.\u003c/p\u003e\n\u003ch3 id=\"components-javascript\"\u003eComponents: JavaScript:\u003c/h3\u003e\n\u003cp\u003eJavaScript is used to consume the data and output the content into the DOM. JavaScript\u0026apos;s involvement in components is the glue that ties everything together.  We can use Javascript to consume the HTML and return a component version of it!  The how-to of JavaScript will be explained in greater detail throughout the rest of our objectives.\u003c/p\u003e\n\u003ch2 id=\"follow-along\"\u003eFollow Along\u003c/h2\u003e\n\u003cp\u003eLet\u0026apos;s identify component patterns in the wild.  Lets go to a social media platform and discuss how components are used.\u003c/p\u003e\n\u003ch2 id=\"challenge\"\u003eChallenge\u003c/h2\u003e\n\u003cp\u003eGo to your favorite social media platform and practice identifying how components are used throughout the app.  Screenshot a component and try recreating the HTML, CSS.  You could even try to create simple DOM interactions in JavaScript.\u003c/p\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 2 - write a function that utilizes createElement and returns a new DOM element",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 3,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 3 - Components I",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/v9t4bu7ber\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eSometimes it makes sense to build several elements with similar functionality. Perhaps lots of components have click handlers that use the same callback, or a group of components shares the same style. This verbosity can be frustrating, but thankfully, it isn\u0026apos;t necessary to repeat yourself in code. Utilizing a Javascript function, we can create dynamic components on the fly and add them to the DOM.\u003c/p\u003e\n\u003ch3 id=\"createelement\"\u003ecreateElement\u003c/h3\u003e\n\u003cp\u003eWe know about the \u003ccode\u003e.createElement\u003c/code\u003e method in our previous lessons. We learned that it could build DOM elements that we can later add to the DOM.\u003c/p\u003e\n\u003cp\u003eWe also learned that once we create an element, we can use any property or method on it as we use on an element selected from the DOM. We can even add event listeners to the newly formed element.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003elet button = document.createElement(\u0026apos;button\u0026apos;);\n\nbutton.textContent = \u0026apos;Button 1\u0026apos;;\n\nbutton.classList.add(\u0026apos;button\u0026apos;);\n\nbutton.addEventListener(\u0026apos;click\u0026apos;, (e) =\u0026gt; {\n    console.log(\u0026apos;clicked!\u0026apos;);\n});\n\nparent.appendChild(button);\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"functions\"\u003efunctions\u003c/h3\u003e\n\u003cp\u003eNow, sticking with that last example, let\u0026apos;s imagine we want to create many buttons on our page. We could very quickly repeat the code there for each button we want to create, appending them to the parent each time. Although from our knowledge so far, we know that repeating ourselves is something we want to avoid. We can easily compartmentalize all of the code into a function. Looking back on that last example, can you identify the pieces that might change? Anything that may change, we can add in as an argument, everything else will stay the same. This function will allow us to create components.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003efunction buttonCreator(buttonText){\n    const button = document.createElement(\u0026apos;button\u0026apos;);\n\n    button.textContent = buttonText;\n\n    button.classList.add(\u0026apos;button\u0026apos;);\n\n    button.addEventListener(\u0026apos;click\u0026apos;, (e) =\u0026gt; {\n        console.log(\u0026apos;clicked!\u0026apos;);\n    });\n\n    return button;\n}\n\nlet firstButton = buttonCreator(\u0026apos;Button 1\u0026apos;);\n\nlet secondButton = buttonCreator(\u0026apos;Button 2\u0026apos;);\n\nparent.appendChild(firstButton);\nparent.appendChild(secondButton);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd just like that, we can create as many new \u003ccode\u003ebutton\u003c/code\u003e components we want without repeating ourselves!\u003c/p\u003e\n\u003c!---##Follow Along---\u003e\n\u003c!---##Challenge---\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 3 - iterate over a list of data creating a new component for each item and attaching that component to the DOM",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 3,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 3 - Components I",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/2obb51cs1e\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eIn the next lesson, we will learn how to retrieve dynamic data, but for now, we are going to build and use our own array. Let\u0026apos;s imagine that this data can change and may not always look like how we built it. We want a way to create components based on the data present. This data can come in many different forms. In this simple case, we are using an array of strings:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst data = [\n    \u0026quot;Button One\u0026quot;,\n    \u0026quot;Button Two\u0026quot;,\n    \u0026quot;Button Three\u0026quot;,\n    \u0026quot;Button Four\u0026quot;\n]\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet\u0026apos;s use the \u003ccode\u003ebuttonCreator\u003c/code\u003e function from the last objective:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003efunction buttonCreator(buttonText){\n    const button = document.createElement(\u0026apos;button\u0026apos;);\n\n    button.textContent = buttonText;\n\n    button.classList.add(\u0026apos;button\u0026apos;);\n\n    button.addEventListener(\u0026apos;click\u0026apos;, (e) =\u0026gt; {\n        console.log(\u0026apos;clicked!\u0026apos;);\n    });\n\n    return button;\n})\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"foreach\"\u003e.forEach\u003c/h3\u003e\n\u003cp\u003eOne of the simplest array methods is \u003ccode\u003e.forEach\u003c/code\u003e - it runs the array through a loop, passing each item to our callback function. It doesn\u0026apos;t return a new array or mutate the data at all (unless we tell it to). \u003ccode\u003e.forEach\u003c/code\u003e is a simple way to iterate over the array, create components, and add them instantly to the DOM.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003edata.forEach((arrayItem) =\u0026gt; {\n  let newButton = buttonCreator(arrayItem);\n\n  parent.appendChild(newButton);\n});\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat was super simple! Just like that, we created a new component for each item in the array and added it to the DOM. No matter how many items are in the array, it will still work. One downside to this method is that we add the items to the DOM instantly, what if we wanted to create the components and add them at a different time?\u003c/p\u003e\n\u003ch3 id=\"map\"\u003e.map\u003c/h3\u003e\n\u003cp\u003eWe know that \u003ccode\u003e.map\u003c/code\u003e returns a new array with the items transformed (by our callback). We can then do whatever we please with this array.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003elet newComponents = data.map((arrayItem) =\u0026gt; {\n  let newButton = buttonCreator(arrayItem);\n\n  // Remember, we always need to return something when we use .map\n  return newButton;\n});\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow that we have an array of DOM elements (components), we can do whatever we\u0026apos;d like with them. We can wait to add the components to the DOM, or we can manipulate them further, the sky is the limit! Let\u0026apos;s add them to the DOM now, using .forEach\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003enewComponents.forEach(component =\u0026gt; {\n  parent.appendChild(component);\n});\u003c/code\u003e\u003c/pre\u003e\n\u003c!---##Follow Along---\u003e\n\u003c!---##Challenge---\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Module 4 Class Recordings",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 4,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 4 - Components II",
              "isHomePage": false,
              "html": "\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/DgrJ6bcyqDI\"\u003eWeb FT36 w/ Gabriel Cabrejas\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/Xq-5u5TzKv4\"\u003eWeb PT21 w/ Emily Seibert\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/w49aH-VVN14\"\u003eWeb PT19 w/ Emily Seibert\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/HI0EFhyHXTM\"\u003eWeb PT18 w/ Keiran Kozolwski\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://youtu.be/XAMKKuJH7PY\"\u003eWeb PT15 w/ Emily Seibert\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 1 - understand and utilize asynchronous Javascript and Promises",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 4,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 4 - Components II",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/5dbzxf5557\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003ch3 id=\"asynchronous-code\"\u003eAsynchronous code\u003c/h3\u003e\n\u003cp\u003eIn JavaScript we have the concept of \u0026apos;asynchronous\u0026apos; code. This simply means code that does not run instantly in line. Perhaps the code needs to wait a moment, wait for something to happen, or in the case we will explore today, wait until data comes back from a server. Using asynchronous code can be challenging at first because we need to be able to recognize which code will be asynchronous and which will run instantly. Take the following example, which will run instantly and which will wait to run?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003esetTimeout( () =\u0026gt; {\n    console.log(\u0026apos;Hello!\u0026apos;);\n}, 1000);\n\nconsole.log(\u0026apos;Over here!\u0026apos;);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEven if you have never seen \u003ccode\u003esetTimeout\u003c/code\u003e before, you probably realized that it will wait a moment to run, where console.log will run instantly. If you run this code in your console you should see \u003ccode\u003eOver here!\u003c/code\u003e print first because setTimeout will wait 1 second (1000 ms) to run.\u003c/p\u003e\n\u003cp\u003eAsynchronous code is everywhere in Javascript. It is an important concept to begin to understand.\u003c/p\u003e\n\u003ch3 id=\"promises\"\u003ePromises\u003c/h3\u003e\n\u003cp\u003eWe have a few different ways to approach asynchronous code, in the last example we saw the use of callbacks (which you already understand). Other concepts are \u003ccode\u003easync/await\u003c/code\u003e and \u003ccode\u003ePromises\u003c/code\u003e. Today we will be using Promises.\u003c/p\u003e\n\u003cp\u003ePromises are a design pattern for use when handling asynchronous code in JavaScript. We use them as an alternative to nesting multiple callbacks. You may have heard of a problem called \u003ccode\u003ecallback\u003c/code\u003e hell. Promises are a way to avoid this problem.\u003c/p\u003e\n\u003cp\u003eImplementing promises is not something you\u0026apos;ll need to do very often, especially in front end development. However, understanding how they work under the hood will help you deal with them, for example when requesting data from web servers.\u003c/p\u003e\n\u003cp\u003eLearning how to handle promises is pretty straight forward. In fact, on a \u003ccode\u003ePromise\u003c/code\u003e object there are really only two methods that we need to use to handle promises \u003ccode\u003ethen\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e. For what we\u0026apos;re trying to accomplish in terms of transferring data between our apps and some server somewhere, we will actually be using what is called a \u003ccode\u003ePromise Library\u003c/code\u003e. I want to ensure that you understand that the built in \u003ccode\u003ePromise\u003c/code\u003e object you\u0026apos;re about to see, is \u003cstrong\u003eNOT\u003c/strong\u003e a promise library, rather it is a feature built into the JavaScript language as of ES6. Now, let\u0026apos;s dig in.\u003c/p\u003e\n\u003cp\u003eConsider the following code and what it is doing here.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003elet time = 0;\nconst timeMachine = () =\u0026gt; {\n  return setTimeout(() =\u0026gt; {\n    return time += 1000;\n  }, 1000);\n};\n\ntimeMachine();\nconsole.log(time); --\u0026gt; OUTPUTS: 0;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat we have seen here is that at some point in time, the setTimeout function (1 second later) will actually end up manipulating the \u003ccode\u003etime\u003c/code\u003e variable. However, when we \u003ccode\u003econsole.log\u003c/code\u003e time we get \u003ccode\u003e0\u003c/code\u003e. The reason for this, is because of the way the \u003ccode\u003etime\u003c/code\u003e variable is defined. It is happening inside of a \u003ccode\u003esetTimeout\u003c/code\u003e block, which waits 1000ms to actually do its thing. This is an important concept to grasp here. \u003cem\u003eEven though we\u0026apos;ve manipulated the data, we don\u0026apos;t have access to the data that was manipulated quite yet\u003c/em\u003e. In a nutshell this is asynchronous JavaScript.\u003c/p\u003e\n\u003cp\u003eOk, so the problem, is that we\u0026apos;re expecting \u003ccode\u003etime\u003c/code\u003e to be equal to \u003ccode\u003e1000\u003c/code\u003e by the time we want to work with it. One way we can solve this is by using Promises. Before we do that let\u0026apos;s figure out what a \u003ccode\u003epromise\u003c/code\u003e is first.\u003c/p\u003e\n\u003cp\u003eStraight from MDN:\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003cp\u003e\u003cem\u003eA Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action\u0026apos;s eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future.\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSimply put, a Promise is just that, a promise from the object that it will let us know when it has completed (or errored) what we have asked it to do.  A promise can exist in one of three states:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePending\u003c/code\u003e: a state where the promise is neither rejected nor fulfilled. (this is the state it is in when we first call it)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFulfilled\u003c/code\u003e: a state where \u003cem\u003eall\u0026apos;s well\u003c/em\u003e and a resolved value can be used by our code.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRejected\u003c/code\u003e: a state where \u003cem\u003esomething went wrong\u003c/em\u003e and there is an error that needs to be dealt with.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf the promise succeeds, it will return the value as a parameter into a callback passed into \u003ccode\u003e.then()\u003c/code\u003e. If the promise fails, the callback passed into the \u003ccode\u003e.catch()\u003c/code\u003e runs, taking an error as its argument.\u003c/p\u003e\n\u003ch2 id=\"follow-along\"\u003eFollow Along\u003c/h2\u003e\n\u003cp\u003eOk that\u0026apos;s a lot of words, now lets see some code.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReminder, we \u003cem\u003eare\u003c/em\u003e building our own promise here, although you will \u003cem\u003enot\u003c/em\u003e need to do this on your own today.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003elet time = 0;\nconst timeMachine = () =\u0026gt; {\n  return new Promise((resolve, reject) =\u0026gt; {\n    setTimeout(() =\u0026gt; {\n      resolve((time += 1000));\n    }, 1000);\n  });\n};\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice here that we\u0026apos;ve now wrapped our \u003ccode\u003esetTimeout\u003c/code\u003e function in a \u003ccode\u003enew Promise\u003c/code\u003e and we\u0026apos;re resolving the addition of the \u003ccode\u003etime += 1000\u003c/code\u003e and passing that resolved result. This allows us to do what we call \u003ccode\u003epromise chaining\u003c/code\u003e when we invoke our \u003ccode\u003etimeMachine\u003c/code\u003e function. Remember that every promise ships with \u003ccode\u003ethen and catch\u003c/code\u003e methods and we can use those methods to either receive a \u003ccode\u003eresolved promise\u003c/code\u003e or a \u003ccode\u003erejected promise\u003c/code\u003e. Lets find out how!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003etimeMachine()\n    .then(newTime =\u0026gt; {\n       console.log(newTime); --\u0026gt; OUTPUTS: 1000\n    });\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOk, in the above code, the \u003ccode\u003ethenified\u003c/code\u003e timeMachine invocation is now receiving a callback itself, (this is how all promise chains should look) with some item being received as a parameter. We can chain multiple \u003ccode\u003ethens\u003c/code\u003e together. Inside of each \u003ccode\u003ethen\u003c/code\u003e block when/if we return something new, we can be directed into a new \u003ccode\u003ethen\u003c/code\u003e block which is really neat. Or maybe we\u0026apos;re \u003ccode\u003eresolving\u003c/code\u003e more than one process, and we want to see the next result in the next \u003ccode\u003ethen\u003c/code\u003e block. Lets manipulate the data in the \u003ccode\u003e.then\u003c/code\u003e block we have now, and see what happens when we use another \u003ccode\u003ethen\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003etimeMachine()\n  .then(newTime =\u0026gt; {\n    const myTime = newTime / 1000;\n    return `${myTime} seconds have passed`;\n  })\n  .then(newString =\u0026gt; {\n    console.log(newString); --\u0026gt; OUTPUTS \u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026quot;1 seconds have passed\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026quot;\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn our first \u003ccode\u003ethen\u003c/code\u003e block we are manipulating the time that is originally being resolved by the \u003ccode\u003ePromise\u003c/code\u003e and then sequentially returning it with some text concatenated onto the time. Because we are returning a value from our first \u003ccode\u003ethen\u003c/code\u003e statement, we can now chain on another \u003ccode\u003ethen\u003c/code\u003e. And thus we have achieved some promise chaining. This isn\u0026apos;t a terribly useful program at this point. But we\u0026apos;re about to see some power.\u003c/p\u003e\n\u003cp\u003eNow lets make another function that we can use to return yet another promise. This is where some of the \u003ccode\u003ethen chaining\u003c/code\u003e starts to really come in handy. We\u0026apos;re going to have to refactor our code, ONLY where we\u0026apos;re calling \u003ccode\u003etimeMachine\u003c/code\u003e. The function we\u0026apos;re going to write is called \u003ccode\u003eparseTime\u003c/code\u003e and it will receive a \u003ccode\u003ems\u003c/code\u003e milliseconds parameter that we can use to reject a promise in the future.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst parseTime = ms =\u0026gt; {\n  return new Promise((resolve, reject) =\u0026gt; {\n    const timeString = time / 1000;\n    resolve(`${timeString} seconds have passed`);\n  });\n};\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOk! Now we\u0026apos;ve offloaded some work from our \u003ccode\u003ethen\u003c/code\u003e block into a function that resolves a promise. We can now use it like above, but this time, when we call our \u003ccode\u003etimeMachine\u003c/code\u003e function  we\u0026apos;ll pass this \u003ccode\u003eparseTime\u003c/code\u003e function as an argument to our first \u003ccode\u003ethen\u003c/code\u003e block.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003etimeMachine()\n  .then(parseTime)\n  .then(timePassed =\u0026gt; {\n    console.log(timePassed); --\u0026gt; OUTPUTS: \u0026quot;1 seconds have passed\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026quot;\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe\u0026apos;ve effectively achieved the same thing, but now we\u0026apos;re chaining promises and their resolves together. This is Promise chaining. Now the last thing we need to cover is a \u003ccode\u003erejected promise\u003c/code\u003e because up until now all the things have just\u0026#x2026; worked. That is not the case in the real world, so because of that, we need to learn how to handle rejections. Lets tweak our \u003ccode\u003eparseTime\u003c/code\u003e function so that we can reject a promise instead of resolving a promise that is, if a certain condition matches.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003econst parseTime = ms =\u0026gt; {\n  return new Promise((resolve, reject) =\u0026gt; {\n    const timeString = time / 1000;\n    if (ms \u0026gt; 999) {\n      resolve(`${timeString} seconds have passed`);\n    } else {\n      reject(new Error(`ms is less than 1 second promise rejected!`));\n    }\n  });\n};\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere\u0026apos;s what\u0026apos;s going to be sweet, when this function actually runs, ms will be 1000. So our condition will resolve the promise, but lets remember where we\u0026apos;re actually using this function.. it\u0026apos;s within a \u003ccode\u003ethen\u003c/code\u003e block on the resolve of another promise. If we tweak our \u003ccode\u003etimeMachine\u003c/code\u003e function to resolve under \u003ccode\u003e1000 ms\u003c/code\u003e, we\u0026apos;ll get a rejection. So lets change the \u003ccode\u003etimeMachine\u003c/code\u003e function in such a way that breaks our promise chain so that we can deal with it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003eresolve((time += 999));\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we should hit our condition, and our promise will then be rejected. So we have a \u003ccode\u003ecatch\u003c/code\u003e block for this purpose.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003etimeMachine()\n  .then(parseTime)\n  .then(timePassed =\u0026gt; {\n    console.log(timePassed); --\u0026gt; OUTPUT: DOES NOT RUN\n  })\n  .catch(err =\u0026gt; {\n    console.log(err); --\u0026gt; OUTPUT: \u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026#x200B;[Error: ms is less than 1 second promise rejected!]\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026#x200B;\u0026#x200B;\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd that is that! We have successfully built out a promise chain that allows us to see the benefit of writing them in the first place. So now, when you\u0026apos;re dealing with Promises in the future, the \u003ccode\u003e.then\u003c/code\u003e and \u003ccode\u003e.catch\u003c/code\u003e won\u0026apos;t be all that scary! That last part is the part to remember. HOW we handle promises is what is important for us in the future. Not HOW we implement them. We will be using Axios for that and we\u0026apos;re going to teach you what that is soon.\u003c/p\u003e\n\u003ch2 id=\"challenge\"\u003eChallenge\u003c/h2\u003e\n\u003cp\u003eUsing the time machine example you just built, build one more function from scratch that returns a \u003ccode\u003ePromise\u003c/code\u003e that has a setTimeout inside it. In the \u003ccode\u003e.then()\u003c/code\u003e console.log what is resolved from inside the setTimeout.\u003c/p\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 2 - understand HTTP requests and get data from a server using axios",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 4,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 4 - Components II",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/1vtjx0csu6\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003ch3 id=\"http\"\u003eHTTP\u003c/h3\u003e\n\u003cp\u003eHTTP is a \u003cem\u003enetwork protocol\u003c/em\u003e, a set of rules that govern the way web clients, like a browser, communicate with web servers over the internet.\u003c/p\u003e\n\u003cp\u003eWe, as developers, need to know what HTTP Methods are and how they are used to perform CRUD (Create, Read, Update, Delete) operations on server resources and what HTTP status codes are and what they are used for.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eHTTP Methods\u003c/code\u003e provide a common \u003cem\u003elanguage\u003c/em\u003e or nomenclature that the client can use to let the server know what operation it wants to perform.\u003c/p\u003e\n\u003cp\u003eWhen a client needs to ask a server for information it should do a GET request specifying a URL that points to the desired resource.\u003c/p\u003e\n\u003cp\u003eA POST request is used to ask the server to add or \u003cem\u003ecreate\u003c/em\u003e new resources.\u003c/p\u003e\n\u003cp\u003eThe method used by the client to ask the server to make changes to specific resources is PUT.\u003c/p\u003e\n\u003cp\u003eTo remove or delete data from the server the client needs to send a DELETE request.\u003c/p\u003e\n\u003cp\u003eWe will see examples of how to use those methods from our React Applications.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eHTTP Status Codes\u003c/code\u003e are used to indicate if a \u003cem\u003erequest\u003c/em\u003e has been successful or not and \u003cstrong\u003ewhy\u003c/strong\u003e. The server will set the status code for all responses sent to the client.\u003c/p\u003e\n\u003ch3 id=\"axios\"\u003eaxios\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eaxios\u003c/code\u003e is a Javascript library. It is used to send HTTP requests to servers. It is \u003cem\u003enot\u003c/em\u003e necessary to do this, but it makes things much easier. Because all server requests are asynchronous, \u003ccode\u003eaxios\u003c/code\u003e uses Promises. Once you get the basic pattern down, \u003ccode\u003eaxios\u003c/code\u003e is incredibly easy to use.\u003c/p\u003e\n\u003cp\u003eTo read more you can check out the documentation here: \u003ca href=\"https://github.com/axios/axios\"\u003ehttps://github.com/axios/axiosn\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eIn this lesson we are only going to concern ourselves with the HTTP GET request, this will allow us to ask a server for data.\u003c/p\u003e\n\u003cp\u003eWe need to start by including some code in our HTML file, this will essentially download axios and allow us to use it in our own javascript file.\u003c/p\u003e\n\u003cp\u003eWe will put the following line in the \u003ccode\u003ehead\u003c/code\u003e section of our HTML:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"html language-html\"\u003e\u0026lt;script src=\u0026quot;https://unpkg.com/axios/dist/axios.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow that we have access to the axios library in our Javascript file we can start to use it. For now we will just use it to request data from a server when we load the page, although we could request that data based on user interaction, or anything really.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eaxios\u003c/code\u003e is an object containing many methods, \u003ccode\u003e.get\u003c/code\u003e being one of them. It takes a string as its first argument. This string is the url of the resource we are requesting:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003eaxios.get(url)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eaxios.get will return a Promise to us. This tells us that it is busy getting the data and will return in a moment. As with all promises, we will use \u003ccode\u003e.then\u003c/code\u003e and \u003ccode\u003e.catch\u003c/code\u003e to deal with the data.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003eaxios.get(\u0026apos;http://serverlocation.com/data\u0026apos;)\n    .then( response =\u0026gt; {\n        // deal with the response data in here\n    })\n    .catch( err =\u0026gt; {\n        // deal with the error in here\n    })\u003c/code\u003e\u003c/pre\u003e\n\u003c!---##Follow Along---\u003e\n\u003c!---##Challenge---\u003e"
            }, {
              "canvasCourseId": 880,
              "title": "Objective 3 - iterate over a list of data received from a server, creating a set of components and adding them to the DOM",
              "courseTrack": "web",
              "unitNumber": 2,
              "sprintNumber": 1,
              "moduleNumber": 4,
              "unitName": "02-WebApplications-I",
              "sprintName": "Sprint 01 - Applied JavaScript",
              "moduleName": "Module 4 - Components II",
              "isHomePage": false,
              "html": "\u003cp\u003e\u003ccenter\u003e\u003cdiv class=\"wistia_responsive_padding\" style=\"padding:56.25% 0 0 0;position:relative;\"\u003e\u003cdiv class=\"wistia_responsive_wrapper\" style=\"height:100%;left:0;position:absolute;top:0;width:100%;\"\u003e\u003ciframe allow=\"autoplay; fullscreen\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" class=\"wistia_embed\" name=\"wistia_embed\" allowfullscreen msallowfullscreen width=\"100%\" height=\"100%\" data-src=\"https://lambdaschool-1.wistia.com/medias/77g6okuf2t\"\u003e\u003c/iframe\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript src=\"https://fast.wistia.net/assets/external/E-v1.js\" async\u003e\u003c/script\u003e\u003c/center\u003e\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003ePutting everything together we can now build a component function, request dynamic data from a server, build components based on that data, and add those components to the DOM.\u003c/p\u003e\n\u003cp\u003eLet\u0026apos;s see it in action:\u003c/p\u003e\n\u003cp\u003eFirst we will build our component creator function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003efunction buttonCreator(buttonTitle){\n    let newButton = document.createElement(\u0026apos;button\u0026apos;);\n    newButton.textContent = buttonTitle;\n    newButton.classList.add(\u0026apos;button\u0026apos;);\n\n    return newButton;\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, let\u0026apos;s grab some data. Once we receieve the data we will map over it and create components out of it. Then we can add it to the DOM:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOne important thing to note is that the data that comes back from the server will be formatted differently for every server. It is good practice to either read the documentation of the server you are using, or inspect the data yourself before attempting to use it. In this example the \u003ccode\u003eresponse\u003c/code\u003e object will have a key on it called \u003ccode\u003edata\u003c/code\u003e that key will have a value of an array with a list of strings.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"javascript language-javascript\"\u003eaxios.get(\u0026apos;http://fakeserver.com/data\u0026apos;)\n    .then( response =\u0026gt; {\n        // Remember response is an object, response.data is an array.\n        response.data.forEach( item =\u0026gt; {\n            let button = buttonCreator(item);\n            parent.appendChild(button);\n        })\n    })\n    .catch( error =\u0026gt; {\n        console.log(\u0026quot;Error:\u0026quot;, err);\n    })\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd there you have it! We have retrieved data, created new components based on that data, and added them to the DOM!\u003c/p\u003e\n\u003c!---##Follow Along---\u003e\n\u003c!---##Challenge---\u003e"
            } ]
          },
          "__N_SSG": true
        },
        "page": "/tracks/[trackSlug]/units/[unitSlug]/sprints/[sprintSlug]",
        "query": {
          "trackSlug": "web-development",
          "unitSlug": "webapplications-i",
          "sprintSlug": "applied-javascript"
        },
        "buildId": "rVvuGS-_4FSBUjsNx_7lz",
        "nextExport": false,
        "isFallback": false,
        "gsp": true
      }

    </script>
    <script nomodule="" src="/_next/static/chunks/polyfills-feb8a7604fa7fce626b2.js"></script>
    <script src="/_next/static/chunks/main-bcea29cef485d2ff4f28.js" async=""></script>
    <script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script>
    <script src="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" async=""></script>
    <script src="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.1d7278d5916139ff8fd5.js" async="">
    </script>
    <script src="/_next/static/chunks/pages/_app-bc37be3f9ebfb49934f6.js" async=""></script>
    <script src="/_next/static/chunks/62fd6c6d.3169d2aaf47600f9c274.js" async=""></script>
    <script src="/_next/static/chunks/5a6ca47b17dc4bcb9b0bc3131ee7e9f4fd30e305.b64ed04365f9737cb9ea.js" async="">
    </script>
    <script
      src="/_next/static/chunks/pages/tracks/%5BtrackSlug%5D/units/%5BunitSlug%5D/sprints/%5BsprintSlug%5D-2093e8ce28f6da0e7dee.js"
      async=""></script>
    <script src="/_next/static/rVvuGS-_4FSBUjsNx_7lz/_buildManifest.js" async=""></script>
    <script src="/_next/static/rVvuGS-_4FSBUjsNx_7lz/_ssgManifest.js" async=""></script>
    <script>
      document.write( '<a href="' + document.referrer + '">Go Back</a>' );

    </script>
    <input type="button" value="Go Back From Whence You Came!" onclick="history.back(-1)" />
  </body>

</html>
